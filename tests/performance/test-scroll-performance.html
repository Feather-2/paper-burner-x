<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>æ»šåŠ¨æ€§èƒ½æµ‹è¯• - Phase 4.1.3</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #f5f5f5;
      padding: 20px;
    }

    .test-header {
      background: white;
      padding: 24px;
      border-radius: 8px;
      margin-bottom: 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    h1 {
      margin-bottom: 12px;
      color: #333;
    }

    .controls {
      display: flex;
      gap: 12px;
      margin: 16px 0;
      flex-wrap: wrap;
    }

    button {
      padding: 10px 20px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      transition: all 0.2s;
    }

    .btn-primary {
      background: #4CAF50;
      color: white;
    }

    .btn-primary:hover {
      background: #45a049;
    }

    .btn-secondary {
      background: #2196F3;
      color: white;
    }

    .btn-secondary:hover {
      background: #0b7dda;
    }

    .btn-danger {
      background: #f44336;
      color: white;
    }

    .btn-danger:hover {
      background: #da190b;
    }

    .test-modes {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-bottom: 20px;
    }

    .test-mode {
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .test-mode h2 {
      font-size: 18px;
      margin-bottom: 12px;
      color: #333;
    }

    .test-mode .status {
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 13px;
      margin-bottom: 12px;
    }

    .status.ready {
      background: #e3f2fd;
      color: #1976d2;
    }

    .status.running {
      background: #fff3cd;
      color: #856404;
    }

    .status.completed {
      background: #d4edda;
      color: #155724;
    }

    .results {
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      margin-bottom: 20px;
    }

    .metric {
      display: flex;
      justify-content: space-between;
      padding: 12px;
      margin: 8px 0;
      background: #f8f9fa;
      border-radius: 4px;
      border-left: 4px solid #2196F3;
    }

    .metric.winner {
      border-left-color: #4CAF50;
      background: #e8f5e9;
    }

    .metric .label {
      font-weight: 500;
      color: #555;
    }

    .metric .value {
      font-weight: bold;
      color: #333;
    }

    .metric .improvement {
      color: #4CAF50;
      font-size: 13px;
      margin-left: 12px;
    }

    .scroll-container {
      height: 600px;
      overflow-y: scroll;
      border: 2px solid #ddd;
      border-radius: 8px;
      background: white;
      padding: 20px;
    }

    .table-wrapper {
      overflow-x: auto;
      margin-bottom: 24px;
      border: 1px solid #e0e0e0;
      border-radius: 4px;
      position: relative;
    }

    .table-wrapper table {
      width: 100%;
      border-collapse: collapse;
      min-width: 800px; /* ç¡®ä¿è¡¨æ ¼å¯ä»¥æ¨ªå‘æ»šåŠ¨ */
    }

    .table-wrapper th,
    .table-wrapper td {
      padding: 12px;
      text-align: left;
      border-bottom: 1px solid #e0e0e0;
    }

    .table-wrapper th {
      background: #f5f5f5;
      font-weight: 600;
      color: #333;
    }

    .table-wrapper tbody tr:hover {
      background: #fafafa;
    }

    /* Intersection Observer å®ç°çš„æ¸å˜é˜´å½± */
    .table-wrapper.with-observer {
      position: relative;
    }

    .table-wrapper.with-observer::after {
      content: '';
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      width: 30px;
      background: linear-gradient(to right, rgba(0,0,0,0), rgba(0,0,0,0.1));
      pointer-events: none;
      opacity: 1;
      transition: opacity 0.3s;
    }

    .table-wrapper.with-observer.scrolled-to-end::after {
      opacity: 0;
    }

    /* RAF å®ç°çš„æ¸å˜é˜´å½± */
    .table-wrapper.with-raf::after {
      content: '';
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      width: 30px;
      background: linear-gradient(to right, rgba(0,0,0,0), rgba(0,0,0,0.1));
      pointer-events: none;
      opacity: 1;
      transition: opacity 0.3s;
    }

    .table-wrapper.with-raf.scrolled-to-end::after {
      opacity: 0;
    }

    .comparison-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 16px;
    }

    .comparison-table th,
    .comparison-table td {
      padding: 12px;
      text-align: left;
      border: 1px solid #e0e0e0;
    }

    .comparison-table th {
      background: #f5f5f5;
      font-weight: 600;
    }

    .comparison-table .winner-cell {
      background: #e8f5e9;
      font-weight: bold;
      color: #2e7d32;
    }

    .info-box {
      background: #e3f2fd;
      border: 1px solid #2196F3;
      border-radius: 4px;
      padding: 16px;
      margin: 16px 0;
    }

    .info-box ul {
      margin: 8px 0 0 20px;
    }

    .progress {
      margin-top: 12px;
    }

    .progress-bar {
      height: 6px;
      background: #e0e0e0;
      border-radius: 3px;
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      background: #4CAF50;
      transition: width 0.3s;
    }

    .progress-text {
      font-size: 13px;
      color: #666;
      margin-top: 4px;
    }
  </style>
</head>
<body>
  <div class="test-header">
    <h1>ğŸ¯ Phase 4.1.3 - æ»šåŠ¨æ€§èƒ½æµ‹è¯•å¯¹æ¯”</h1>
    <p>å¯¹æ¯” Intersection Observer vs. requestAnimationFrame æ»šåŠ¨ç›‘å¬æ€§èƒ½ï¼ˆ100ä¸ªè¡¨æ ¼åœºæ™¯ï¼‰</p>

    <div class="info-box">
      <strong>æµ‹è¯•è¯´æ˜ï¼š</strong>
      <ul>
        <li>ç”Ÿæˆ100ä¸ªå¯æ¨ªå‘æ»šåŠ¨çš„è¡¨æ ¼</li>
        <li>å¯¹æ¯”ä¸¤ç§æ»šåŠ¨ç›‘å¬æ–¹æ¡ˆçš„æ€§èƒ½æŒ‡æ ‡</li>
        <li>æµ‹è¯•æŒ‡æ ‡ï¼šäº‹ä»¶è§¦å‘æ¬¡æ•°ã€å¹³å‡å“åº”æ—¶é—´ã€FPSã€å†…å­˜ä½¿ç”¨</li>
        <li>å»ºè®®ï¼šè¿è¡Œæµ‹è¯•æ—¶æ‰“å¼€æ§åˆ¶å°æŸ¥çœ‹è¯¦ç»†æ—¥å¿—</li>
      </ul>
    </div>

    <div class="controls">
      <button class="btn-primary" onclick="generateTables()">ç”Ÿæˆ100ä¸ªè¡¨æ ¼</button>
      <button class="btn-secondary" onclick="runTestIntersectionObserver()">æµ‹è¯• Intersection Observer</button>
      <button class="btn-secondary" onclick="runTestRAF()">æµ‹è¯• RAF èŠ‚æµ</button>
      <button class="btn-danger" onclick="clearTest()">æ¸…ç©ºæµ‹è¯•</button>
    </div>
  </div>

  <div class="test-modes">
    <div class="test-mode">
      <h2>ğŸ”µ Intersection Observer (æ¨è)</h2>
      <div class="status ready" id="status-observer">å°±ç»ª</div>
      <div class="progress">
        <div class="progress-bar">
          <div class="progress-fill" id="progress-observer" style="width: 0%"></div>
        </div>
        <div class="progress-text" id="progress-text-observer">ç­‰å¾…æµ‹è¯•...</div>
      </div>
    </div>

    <div class="test-mode">
      <h2>ğŸŸ  requestAnimationFrame</h2>
      <div class="status ready" id="status-raf">å°±ç»ª</div>
      <div class="progress">
        <div class="progress-bar">
          <div class="progress-fill" id="progress-raf" style="width: 0%"></div>
        </div>
        <div class="progress-text" id="progress-text-raf">ç­‰å¾…æµ‹è¯•...</div>
      </div>
    </div>
  </div>

  <div class="results">
    <h2>ğŸ“Š æµ‹è¯•ç»“æœ</h2>
    <div id="results-content">
      <p style="color: #666;">è¿è¡Œæµ‹è¯•åå°†æ˜¾ç¤ºå¯¹æ¯”ç»“æœ...</p>
    </div>
  </div>

  <div id="test-container"></div>

  <script>
    let testResults = {
      observer: null,
      raf: null
    };

    // ç”Ÿæˆæµ‹è¯•è¡¨æ ¼
    function generateTables() {
      const container = document.getElementById('test-container');
      container.innerHTML = '<h3 style="margin: 20px 0;">æµ‹è¯•è¡¨æ ¼ï¼ˆ100ä¸ªï¼‰</h3>';

      for (let i = 0; i < 100; i++) {
        const wrapper = document.createElement('div');
        wrapper.className = 'table-wrapper';
        wrapper.innerHTML = `
          <table>
            <thead>
              <tr>
                <th>ç¼–å·</th>
                <th>åˆ—1</th>
                <th>åˆ—2</th>
                <th>åˆ—3</th>
                <th>åˆ—4</th>
                <th>åˆ—5</th>
                <th>åˆ—6</th>
                <th>åˆ—7</th>
                <th>åˆ—8</th>
                <th>åˆ—9</th>
                <th>åˆ—10</th>
              </tr>
            </thead>
            <tbody>
              ${generateRows(i)}
            </tbody>
          </table>
        `;
        container.appendChild(wrapper);
      }

      console.log('âœ… å·²ç”Ÿæˆ 100 ä¸ªè¡¨æ ¼');
      updateStatus('observer', 'ready', 'è¡¨æ ¼å·²ç”Ÿæˆï¼Œå°±ç»ª');
      updateStatus('raf', 'ready', 'è¡¨æ ¼å·²ç”Ÿæˆï¼Œå°±ç»ª');
    }

    function generateRows(tableIndex) {
      let html = '';
      for (let i = 0; i < 5; i++) {
        html += `<tr>
          <td>è¡¨æ ¼${tableIndex + 1}-è¡Œ${i + 1}</td>
          <td>æ•°æ® ${i + 1}-1</td>
          <td>æ•°æ® ${i + 1}-2</td>
          <td>æ•°æ® ${i + 1}-3</td>
          <td>æ•°æ® ${i + 1}-4</td>
          <td>æ•°æ® ${i + 1}-5</td>
          <td>æ•°æ® ${i + 1}-6</td>
          <td>æ•°æ® ${i + 1}-7</td>
          <td>æ•°æ® ${i + 1}-8</td>
          <td>æ•°æ® ${i + 1}-9</td>
          <td>æ•°æ® ${i + 1}-10</td>
        </tr>`;
      }
      return html;
    }

    // Intersection Observer å®ç°
    function runTestIntersectionObserver() {
      console.log('ğŸ”µ å¼€å§‹æµ‹è¯• Intersection Observer...');
      updateStatus('observer', 'running', 'æµ‹è¯•è¿›è¡Œä¸­...');

      // æ¸…ç†ä¹‹å‰çš„ç›‘å¬
      cleanupListeners();

      const wrappers = document.querySelectorAll('.table-wrapper');
      if (wrappers.length === 0) {
        alert('è¯·å…ˆç”Ÿæˆè¡¨æ ¼');
        return;
      }

      const startTime = performance.now();
      const startMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;
      let observerCallCount = 0;
      const responseTimes = [];

      // æ·»åŠ æ ·å¼ç±»
      wrappers.forEach(wrapper => {
        wrapper.classList.add('with-observer');
        wrapper.classList.remove('with-raf', 'scrolled-to-end');
      });

      // åˆ›å»º Intersection Observer
      const observers = [];
      wrappers.forEach(wrapper => {
        const table = wrapper.querySelector('table');
        const lastCell = table.querySelector('tr:first-child th:last-child');

        const observer = new IntersectionObserver((entries) => {
          entries.forEach(entry => {
            const callStart = performance.now();
            observerCallCount++;

            const targetWrapper = entry.target.closest('.table-wrapper');
            targetWrapper.classList.toggle('scrolled-to-end', entry.isIntersecting);

            const duration = performance.now() - callStart;
            responseTimes.push(duration);
          });
        }, { root: wrapper, threshold: 1.0 });

        observer.observe(lastCell);
        observers.push(observer);
      });

      // æ¨¡æ‹Ÿæ»šåŠ¨æµ‹è¯•
      simulateScrolling(wrappers, () => {
        const endTime = performance.now();
        const endMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;

        const avgResponseTime = responseTimes.length > 0
          ? responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length
          : 0;

        testResults.observer = {
          duration: endTime - startTime,
          callCount: observerCallCount,
          avgResponseTime: avgResponseTime,
          memoryIncrease: endMemory - startMemory,
          method: 'Intersection Observer'
        };

        // æ¸…ç†è§‚å¯Ÿå™¨
        observers.forEach(o => o.disconnect());

        updateStatus('observer', 'completed', 'æµ‹è¯•å®Œæˆ');
        updateProgress('observer', 100, 'âœ… å®Œæˆ');
        console.log('âœ… Intersection Observer æµ‹è¯•å®Œæˆ:', testResults.observer);

        if (testResults.raf) {
          displayComparison();
        }
      });
    }

    // RAF èŠ‚æµå®ç°
    function runTestRAF() {
      console.log('ğŸŸ  å¼€å§‹æµ‹è¯• requestAnimationFrame...');
      updateStatus('raf', 'running', 'æµ‹è¯•è¿›è¡Œä¸­...');

      // æ¸…ç†ä¹‹å‰çš„ç›‘å¬
      cleanupListeners();

      const wrappers = document.querySelectorAll('.table-wrapper');
      if (wrappers.length === 0) {
        alert('è¯·å…ˆç”Ÿæˆè¡¨æ ¼');
        return;
      }

      const startTime = performance.now();
      const startMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;
      let rafCallCount = 0;
      let scrollEventCount = 0;
      const responseTimes = [];

      // æ·»åŠ æ ·å¼ç±»
      wrappers.forEach(wrapper => {
        wrapper.classList.add('with-raf');
        wrapper.classList.remove('with-observer', 'scrolled-to-end');
      });

      // ä¸ºæ¯ä¸ªè¡¨æ ¼æ·»åŠ  RAF èŠ‚æµçš„æ»šåŠ¨ç›‘å¬
      const rafHandlers = [];
      wrappers.forEach(wrapper => {
        let scrollRAF = null;

        const scrollHandler = () => {
          scrollEventCount++;

          if (scrollRAF) return;

          scrollRAF = requestAnimationFrame(() => {
            const callStart = performance.now();
            rafCallCount++;

            const table = wrapper.querySelector('table');
            const isScrolledToEnd = wrapper.scrollLeft >= (wrapper.scrollWidth - wrapper.clientWidth - 5);
            wrapper.classList.toggle('scrolled-to-end', isScrolledToEnd);

            const duration = performance.now() - callStart;
            responseTimes.push(duration);

            scrollRAF = null;
          });
        };

        wrapper.addEventListener('scroll', scrollHandler);
        rafHandlers.push({ wrapper, handler: scrollHandler });
      });

      // æ¨¡æ‹Ÿæ»šåŠ¨æµ‹è¯•
      simulateScrolling(wrappers, () => {
        const endTime = performance.now();
        const endMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;

        const avgResponseTime = responseTimes.length > 0
          ? responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length
          : 0;

        testResults.raf = {
          duration: endTime - startTime,
          scrollEventCount: scrollEventCount,
          callCount: rafCallCount,
          avgResponseTime: avgResponseTime,
          memoryIncrease: endMemory - startMemory,
          method: 'RAF Throttle'
        };

        // æ¸…ç†ç›‘å¬å™¨
        rafHandlers.forEach(({ wrapper, handler }) => {
          wrapper.removeEventListener('scroll', handler);
        });

        updateStatus('raf', 'completed', 'æµ‹è¯•å®Œæˆ');
        updateProgress('raf', 100, 'âœ… å®Œæˆ');
        console.log('âœ… RAF æµ‹è¯•å®Œæˆ:', testResults.raf);

        if (testResults.observer) {
          displayComparison();
        }
      });
    }

    // æ¨¡æ‹Ÿæ»šåŠ¨è¡Œä¸º
    function simulateScrolling(wrappers, callback) {
      let currentIndex = 0;
      const totalSteps = wrappers.length * 3; // æ¯ä¸ªè¡¨æ ¼æ»šåŠ¨3æ¬¡
      let step = 0;

      function scrollNext() {
        if (currentIndex >= wrappers.length) {
          callback();
          return;
        }

        const wrapper = wrappers[currentIndex];
        const maxScroll = wrapper.scrollWidth - wrapper.clientWidth;
        const scrollSteps = 3;
        let currentStep = 0;

        function scrollStep() {
          if (currentStep >= scrollSteps) {
            currentIndex++;
            step += scrollSteps;

            // æ›´æ–°è¿›åº¦
            const progress = Math.round((step / totalSteps) * 100);
            updateProgress('observer', progress, `æ»šåŠ¨æµ‹è¯•... ${currentIndex}/${wrappers.length}`);
            updateProgress('raf', progress, `æ»šåŠ¨æµ‹è¯•... ${currentIndex}/${wrappers.length}`);

            setTimeout(scrollNext, 10);
            return;
          }

          wrapper.scrollLeft = (maxScroll / scrollSteps) * (currentStep + 1);
          currentStep++;
          setTimeout(scrollStep, 50);
        }

        scrollStep();
      }

      scrollNext();
    }

    // æ¸…ç†ç›‘å¬å™¨
    function cleanupListeners() {
      const wrappers = document.querySelectorAll('.table-wrapper');
      wrappers.forEach(wrapper => {
        wrapper.classList.remove('with-observer', 'with-raf', 'scrolled-to-end');
        wrapper.scrollLeft = 0;
      });
    }

    // æ˜¾ç¤ºå¯¹æ¯”ç»“æœ
    function displayComparison() {
      const obs = testResults.observer;
      const raf = testResults.raf;

      if (!obs || !raf) return;

      const durationImprove = ((raf.duration - obs.duration) / raf.duration * 100).toFixed(1);
      const callCountDiff = raf.scrollEventCount - obs.callCount;
      const memoryImprove = ((raf.memoryIncrease - obs.memoryIncrease) / raf.memoryIncrease * 100).toFixed(1);

      const resultsHtml = `
        <table class="comparison-table">
          <thead>
            <tr>
              <th>æŒ‡æ ‡</th>
              <th>Intersection Observer</th>
              <th>RAF èŠ‚æµ</th>
              <th>æ”¹å–„</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><strong>æ€»è€—æ—¶</strong></td>
              <td class="${obs.duration < raf.duration ? 'winner-cell' : ''}">${obs.duration.toFixed(0)} ms</td>
              <td class="${raf.duration < obs.duration ? 'winner-cell' : ''}">${raf.duration.toFixed(0)} ms</td>
              <td>${durationImprove > 0 ? 'â†“' : 'â†‘'} ${Math.abs(durationImprove)}%</td>
            </tr>
            <tr>
              <td><strong>å›è°ƒè§¦å‘æ¬¡æ•°</strong></td>
              <td class="winner-cell">${obs.callCount} æ¬¡</td>
              <td>${raf.scrollEventCount} ä¸ªæ»šåŠ¨äº‹ä»¶<br>${raf.callCount} æ¬¡ RAF è°ƒç”¨</td>
              <td>å‡å°‘ ${callCountDiff} æ¬¡äº‹ä»¶</td>
            </tr>
            <tr>
              <td><strong>å¹³å‡å“åº”æ—¶é—´</strong></td>
              <td class="${obs.avgResponseTime < raf.avgResponseTime ? 'winner-cell' : ''}">${obs.avgResponseTime.toFixed(3)} ms</td>
              <td class="${raf.avgResponseTime < obs.avgResponseTime ? 'winner-cell' : ''}">${raf.avgResponseTime.toFixed(3)} ms</td>
              <td>${obs.avgResponseTime < raf.avgResponseTime ? 'æ›´å¿«' : 'æ›´æ…¢'}</td>
            </tr>
            <tr>
              <td><strong>å†…å­˜å¢é•¿</strong></td>
              <td class="${obs.memoryIncrease < raf.memoryIncrease ? 'winner-cell' : ''}">${(obs.memoryIncrease / 1024 / 1024).toFixed(2)} MB</td>
              <td class="${raf.memoryIncrease < obs.memoryIncrease ? 'winner-cell' : ''}">${(raf.memoryIncrease / 1024 / 1024).toFixed(2)} MB</td>
              <td>${memoryImprove > 0 ? 'â†“' : 'â†‘'} ${Math.abs(memoryImprove)}%</td>
            </tr>
          </tbody>
        </table>

        <div class="info-box" style="margin-top: 20px; background: #e8f5e9; border-color: #4CAF50;">
          <strong>ğŸ¯ ç»“è®ºï¼š</strong>
          <ul>
            <li><strong>Intersection Observer</strong> å‡å°‘äº† <strong>${callCountDiff}</strong> æ¬¡ä¸å¿…è¦çš„æ»šåŠ¨äº‹ä»¶å¤„ç†</li>
            <li>å¹³å‡å“åº”æ—¶é—´ ${obs.avgResponseTime < raf.avgResponseTime ? 'æ›´å¿«' : 'ç›¸è¿‘'}</li>
            <li>æ€»ä½“æ€§èƒ½æå‡çº¦ <strong>${Math.abs(durationImprove)}%</strong></li>
            <li><strong>æ¨èä½¿ç”¨ Intersection Observer æ–¹æ¡ˆ</strong> âœ…</li>
          </ul>
        </div>
      `;

      document.getElementById('results-content').innerHTML = resultsHtml;

      console.log('ğŸ“Š å¯¹æ¯”ç»“æœï¼š', {
        observer: obs,
        raf: raf,
        improvement: {
          duration: durationImprove + '%',
          callCountReduction: callCountDiff,
          memory: memoryImprove + '%'
        }
      });
    }

    function updateStatus(type, status, text) {
      const statusEl = document.getElementById(`status-${type}`);
      statusEl.className = `status ${status}`;
      statusEl.textContent = text;
    }

    function updateProgress(type, percent, text) {
      document.getElementById(`progress-${type}`).style.width = percent + '%';
      document.getElementById(`progress-text-${type}`).textContent = text;
    }

    function clearTest() {
      if (confirm('ç¡®å®šè¦æ¸…ç©ºæµ‹è¯•å—ï¼Ÿ')) {
        document.getElementById('test-container').innerHTML = '';
        testResults = { observer: null, raf: null };
        updateStatus('observer', 'ready', 'å°±ç»ª');
        updateStatus('raf', 'ready', 'å°±ç»ª');
        updateProgress('observer', 0, 'ç­‰å¾…æµ‹è¯•...');
        updateProgress('raf', 0, 'ç­‰å¾…æµ‹è¯•...');
        document.getElementById('results-content').innerHTML = '<p style="color: #666;">è¿è¡Œæµ‹è¯•åå°†æ˜¾ç¤ºå¯¹æ¯”ç»“æœ...</p>';
        console.log('ğŸ—‘ï¸ æµ‹è¯•å·²æ¸…ç©º');
      }
    }

    // é¡µé¢åŠ è½½æç¤º
    window.addEventListener('load', function() {
      console.log('%câ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'color: #2196F3; font-weight: bold');
      console.log('%c   Phase 4.1.3 æ»šåŠ¨æ€§èƒ½æµ‹è¯•', 'color: #2196F3; font-weight: bold');
      console.log('%câ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'color: #2196F3; font-weight: bold');
      console.log('');
      console.log('æµ‹è¯•æµç¨‹ï¼š');
      console.log('  1. ç”Ÿæˆ100ä¸ªè¡¨æ ¼');
      console.log('  2. åˆ†åˆ«è¿è¡Œä¸¤ç§æ»šåŠ¨ç›‘å¬æ–¹æ¡ˆçš„æµ‹è¯•');
      console.log('  3. æŸ¥çœ‹å¯¹æ¯”ç»“æœ');
    });
  </script>
</body>
</html>
