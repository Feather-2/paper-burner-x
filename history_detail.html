<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <title>å†å²è¯¦æƒ…</title>
  <!-- KaTeX å…¬å¼æ¸²æŸ“æ ·å¼ -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
  <link type="text/css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jsmind/style/jsmind.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
  <link rel="stylesheet" href="css/history_detail.css">
  <style>
    /* NEW DOCK STYLES */
    #bottom-left-dock {
      position: fixed;
      bottom: 15px;
      left: 15px;
      background-color: rgba(255, 255, 255, 0.95); /* UPDATED for more distinct white background */
      border: 1px dashed #94a3b8; /* Keep this border, good for white background */
      color: #334155; /* Keep this text color */
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 12px;
      font-weight: 500;
      z-index: 2000;
      opacity: 0;
      transition: opacity 0.4s ease-in-out, transform 0.2s ease-out, padding 0.2s ease-out, min-width 0.2s ease-out, height 0.2s ease-out;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      display: flex;
      align-items: center;
      gap: 10px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.05); /* UPDATED */
      transform: translateY(10px);
      min-width: 30px;
      height: auto;
    }

    /* TOC æ¨¡å¼é€‰æ‹©å™¨æ ·å¼ */
    .toc-mode-selector {
      display: flex;
      gap: 5px;
      margin: 8px 0;
      padding: 5px;
      background-color: #f5f7fa;
      border-radius: 4px;
      justify-content: center;
    }

    .toc-mode-btn {
      padding: 4px 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background-color: #fff;
      cursor: pointer;
      font-size: 12px;
      transition: all 0.2s ease;
    }

    .toc-mode-btn.active {
      background-color: #3b82f6;
      color: white;
      border-color: #2563eb;
    }

    .toc-mode-btn:hover:not(.active) {
      background-color: #f0f4f8;
    }

    /* è®¾ç½®å¯¹è¯æ¡†ä¸­çš„å•é€‰æŒ‰é’®æ ·å¼ */
    .radio-container {
      margin: 10px 0 15px;
    }

    .radio-group {
      margin-bottom: 8px;
      display: flex;
      align-items: center;
    }

    .radio-group input[type="radio"] {
      margin-right: 8px;
    }

    .radio-group label {
      cursor: pointer;
    }

    /* TOC é«˜äº®æ•ˆæœ */
    .toc-highlight {
      animation: toc-highlight-flash 2s ease-out;
    }

    @keyframes toc-highlight-flash {
      0%, 100% { background-color: transparent; }
      50% { background-color: rgba(59, 130, 246, 0.2); }
    }

    /* è½¬æ¢åçš„æ ‡é¢˜æ ·å¼ */
    .converted-from-heading {
      font-weight: 600;
      margin-top: 1.5em;
      margin-bottom: 0.75em;
      color: #333;
      border-bottom: 1px solid #eee;
      padding-bottom: 5px;
    }

    /* TOC ä¿¡æ¯æç¤ºæ ·å¼ */
    .toc-info {
      padding: 10px;
      margin: 10px 0;
      background-color: #f8f9fa;
      border-left: 3px solid #3b82f6;
      color: #4b5563;
      font-style: italic;
      border-radius: 0 4px 4px 0;
    }

    #bottom-left-dock.visible {
      opacity: 1;
      transform: translateY(0);
    }

    /* Updated styles for dock-info-stack and its new columns */
    #dock-info-stack {
      display: flex;
      flex-direction: row; /* Columns side-by-side */
      gap: 2px; /* Further reduced gap between Label column and Value column */
      align-items: flex-start; /* Align columns at their top */
    }

    .dock-column {
      display: flex;
      flex-direction: column;
      gap: 2px; /* Gap between lines within a column */
    }

    .dock-values-column {
      text-align: right; /* Right-align the values/percentages */
      min-width: 40px; /* Slightly reduced min-width */
    }
    .dock-values-column > div {
      justify-content: flex-end; /* Ensure content within value divs also aligns right if they are flex */
    }

    /* Individual stat items, if they need specific styling for clickability */
    .stat-item-clickable {
      text-decoration: underline;
      cursor: pointer;
    }
    .stat-item-clickable:hover {
      color: #1d4ed8;
    }

    #bottom-left-dock > #dock-info-stack,
    #bottom-left-dock > a,
    #bottom-left-dock > #dock-collapsed-progress-display { /* Added new direct child */
      display: flex;
      align-items: center;
    }

    #dock-stats {
      display: flex;
      gap: 8px; /* Space between highlight and annotation counts */
    }

    #bottom-left-dock a {
      color: #3b82f6; /* Slightly softer blue for links/icons, can be adjusted */
      text-decoration: none;
    }
    #bottom-left-dock a:hover {
      color: #2563eb; /* Darker blue on hover */
    }

    #settings-link i.fa-cog, /* Changed ID */
    #dock-toggle-btn i {
      font-size: 1.2em;
      padding: 3px;
    }
    #dock-toggle-btn {
        margin-left: auto; /* Pushes toggle button to the far right */
        cursor: pointer;
    }

    /* Style for the standalone progress display in collapsed mode */
    /* Ensure it's hidden by default when the dock is NOT collapsed */
    #bottom-left-dock:not(.dock-collapsed) #dock-collapsed-progress-display {
        display: none;
    }

    #dock-collapsed-progress-display {
        /* display: none; */ /* This can be removed if the above :not selector is robust */
        color: #334155; /* Match updated dock text color */
        font-weight: 500;
    }

    /* Collapsed state */
    #bottom-left-dock.dock-collapsed {
      padding: 6px 10px; /* Slightly adjust padding for collapsed state */
      gap: 8px; /* Adjust gap for items in collapsed row */
      /* min-width to allow content to show */
    }

    /* Hide these elements when collapsed */
    #bottom-left-dock.dock-collapsed #dock-info-stack,
    #bottom-left-dock.dock-collapsed #settings-link {
      display: none;
    }

    /* Show and style the specific progress display for collapsed mode */
    #bottom-left-dock.dock-collapsed #dock-collapsed-progress-display {
        display: inline; /* Show it */
    }

    /* This rule is no longer needed as #dock-stats is inside #dock-info-stack which gets hidden */
    /* #bottom-left-dock.dock-collapsed #dock-stats, */

    /* Ensure these are visible in collapsed state - REVISED */
    /* #bottom-left-dock.dock-collapsed #dock-reading-progress, */
    /* #bottom-left-dock.dock-collapsed #settings-link {  */
      /* display: flex; */
      /* align-items: center; */
    /* } */

    /* This rule is no longer needed as #dock-stats is inside #dock-info-stack */
    /* #bottom-left-dock.dock-collapsed #dock-stats span {
        text-decoration: underline;
        cursor: pointer;
    }
    #bottom-left-dock.dock-collapsed #dock-stats span:hover {
        color: #1d4ed8;
    } */

    #bottom-left-dock.dock-collapsed #dock-toggle-btn {
      margin-left: auto; /* Ensure toggle button is pushed to the right if other elements are minimal */
    }

    /* Style for the new sub-blocks, can be adjusted */
    .sub-block {
        display: inline; /* Or inline-block if padding/margin is needed and wrap behavior is desired */
    }

   /* NEW STYLES FOR CENTERING IMAGES AND TABLES from Markdown content */
   .markdown-body img {
     display: block; /* Allows margin auto to work for horizontal centering */
     margin-left: auto;
     margin-right: auto;
     max-width: 100%; /* Ensures image is responsive and doesn't overflow container */
     height: auto;    /* Maintains aspect ratio */
   }

   .markdown-body table {
     display: table;  /* Allows margin auto to work for centering while preserving table layout */
     margin-left: auto;
     margin-right: auto;
     /* width: auto; /* Default for display:table, table will size to its content */
   }

    /* Custom Context Menu Styles (Notion-like) */
    #custom-context-menu {
        background-color: #fff; /* White background */
        border: 1px solid #eee; /* Light border */
        border-radius: 8px; /* Rounded corners */
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); /* Softer shadow */
        padding: 6px 0; /* Vertical padding */
        min-width: 220px; /* Minimum width */
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        font-size: 14px;
        color: #333; /* Darker text color */
        z-index: 10000; /* Ensure it's on top */
    }

    #custom-context-menu ul {
        list-style: none;
        padding: 0;
        margin: 0;
    }

    #custom-context-menu li {
        padding: 8px 12px; /* Padding for items */
        cursor: pointer;
        display: flex;
        align-items: center;
        transition: background-color 0.15s ease-in-out;
    }

    #custom-context-menu li:hover {
        background-color: #f5f5f5; /* Light gray hover */
    }

    #custom-context-menu li i.fa { /* Icon styling */
        margin-right: 10px;
        color: #555;
        width: 16px; /* Fixed width for alignment */
        text-align: center;
    }

    #custom-context-menu .color-palette {
        display: flex;
        align-items: center;
        margin-left: auto; /* Push color palette to the right */
        padding-left: 10px;
    }

    #custom-context-menu .color-option {
        width: 18px;
        height: 18px;
        border-radius: 50%; /* Circular color options */
        margin-left: 6px;
        cursor: pointer;
        border: 1px solid rgba(0,0,0,0.1);
        transition: transform 0.1s ease-out;
    }
    #custom-context-menu .color-option:hover {
        transform: scale(1.15);
    }

    /* Specific color styles - ensure these match your JS color names */
    .color-yellow { background-color: yellow; }
    .color-pink { background-color: pink; }
    .color-lightblue { background-color: lightblue; }
    .color-lightgreen { background-color: lightgreen; }
    .color-purple { background-color: purple; }
    .color-orange { background-color: orange; }

    /* Divider style */
    #custom-context-menu hr.menu-divider {
        border: none;
        border-top: 1px solid #eee;
        margin: 6px 0;
    }

    /* Add underline and pointer to stats in EXPANDED mode as well */
    /* This is now handled by .stat-item-clickable on the specific spans */
    /* #bottom-left-dock:not(.dock-collapsed) #dock-stats span {
        text-decoration: underline;
        cursor: pointer;
    }
    #bottom-left-dock:not(.dock-collapsed) #dock-stats span:hover {
        color: #1d4ed8;
    } */

    /* Annotations Summary Modal CSS */
    #annotations-summary-modal .modal-content {
      max-width: 80%;
      width: 950px;
      max-height: 85vh;
      display: flex;
      flex-direction: column;
      position: relative;
    }
    #annotations-summary-modal .modal-close-btn {
      position: absolute;
      top: 12px;
      right: 18px;
      font-size: 2em;
      color: #888;
      cursor: pointer;
      z-index: 10;
      background: none;
      border: none;
      line-height: 1;
      padding: 0;
      transition: color 0.2s;
    }
    #annotations-summary-modal .modal-close-btn:hover {
      color: #333;
    }
    #annotations-summary-modal .table-container {
      overflow-y: auto;
      flex-grow: 1;
      margin-top: 15px;
      border: 1px solid #e0e0e0; /* Added border for definition */
    }

    #annotations-summary-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }

    #annotations-summary-table th,
    #annotations-summary-table td {
      border: 1px solid #ddd;
      padding: 10px 8px; /* Adjusted padding */
      text-align: left;
      vertical-align: top;
      word-break: break-word; /* Help with long content */
    }

    #annotations-summary-table th {
      background-color: #f7f7f7; /* Lighter background for header */
      position: sticky;
      top: 0;
      z-index: 1;
      font-weight: 600; /* Bolder header text */
    }

    #annotations-summary-table .color-swatch {
      display: inline-block;
      width: 18px; /* Slightly larger */
      height: 18px; /* Slightly larger */
      border: 1px solid #ccc;
      border-radius: 4px; /* Rounded corners */
      vertical-align: middle;
      box-shadow: 0 0 2px rgba(0,0,0,0.1); /* Subtle shadow */
    }

    #annotations-summary-table .action-btn {
      padding: 5px 10px; /* Adjusted padding */
      font-size: 12px;
      cursor: pointer;
      border: 1px solid #007bff; /* Blue border */
      background-color: #fff; /* White background */
      color: #007bff; /* Blue text */
      border-radius: 4px;
      transition: all 0.2s ease;
    }
    #annotations-summary-table .action-btn:hover {
      background-color: #007bff; /* Blue background on hover */
      color: #fff; /* White text on hover */
    }
    #annotations-summary-table .action-btn:disabled {
      border-color: #ccc;
      background-color: #f0f0f0;
      color: #aaa;
      cursor: not-allowed;
    }

    .annotations-summary-controls {
      margin-bottom: 15px;
      display: flex;
      gap: 20px;
      align-items: center;
      padding: 10px;
      background-color: #f9f9f9;
      border-radius: 4px;
      border: 1px solid #e0e0e0;
      flex-wrap: wrap;
    }
    .annotations-summary-controls label {
      margin-right: 5px;
      font-weight: 500;
    }
    .annotations-summary-controls select {
      padding: 6px 8px;
      border-radius: 4px;
      border: 1px solid #ccc;
      background-color: #fff;
    }
    .annotations-summary-color-filter {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-left: 10px;
      flex-wrap: wrap;
    }
    .annotations-summary-color-checkbox {
      display: flex;
      align-items: center;
      gap: 2px;
      margin-right: 6px;
      cursor: pointer;
    }
    .annotations-summary-color-checkbox input[type="checkbox"] {
      margin: 0 2px 0 0;
      accent-color: #007bff;
    }
    .annotations-summary-color-swatch {
      width: 16px;
      height: 16px;
      border-radius: 4px;
      border: 1px solid #bbb;
      display: inline-block;
      margin-right: 2px;
    }
    /* Temporary highlight for jumped-to element */
    .jump-to-highlight-effect { /* Renamed for clarity */
      transition: background-color 0.3s ease-in-out, box-shadow 0.3s ease-in-out;
      background-color: rgba(255, 220, 0, 0.45) !important; /* Softer yellow, more transparent */
      box-shadow: 0 0 12px rgba(255, 220, 0, 0.6) !important; /* Softer glow */
      border-radius: 5px !important; /* Smoother radius */
      outline: 2px solid rgba(255, 200, 0, 0.7); /* Added outline */
    }

    /* æ‰¹æ³¨è¯¦æƒ…æ¨¡æ€æ¡†å¢å¼ºæ ·å¼ */
    #annotations-summary-table td {
      max-width: 250px;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    #annotations-summary-table td:nth-child(4) {
      cursor: pointer;
      position: relative;
    }

    #annotations-summary-table td:nth-child(4):hover {
      background-color: #f0f0f0;
    }

    #annotations-summary-table td:nth-child(4)::after {
      content: "ğŸ‘ï¸";
      position: absolute;
      right: 5px;
      top: 50%;
      transform: translateY(-50%);
      opacity: 0;
      transition: opacity 0.2s;
    }

    #annotations-summary-table td:nth-child(4):hover::after {
      opacity: 0.7;
    }

    /* æ–‡æœ¬ç‰‡æ®µé¢„è§ˆå¯¹è¯æ¡†æ ·å¼ */
    .full-text-dialog {
      animation: fadeIn 0.2s ease-out;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translate(-50%, -48%); }
      to { opacity: 1; transform: translate(-50%, -50%); }
    }

    .full-text-dialog button {
      background-color: #f0f0f0;
      border: 1px solid #ddd;
      border-radius: 4px;
      transition: all 0.2s;
    }

    .full-text-dialog button:hover {
      background-color: #e0e0e0;
    }

    /* é¢œè‰²ç­›é€‰åŒºåŸŸæ ·å¼å¢å¼º */
    .annotations-summary-color-filter {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-left: 10px;
      flex-wrap: wrap;
      padding: 5px;
      border: 1px solid #eee;
      border-radius: 4px;
      background-color: #fafafa;
    }

    .annotations-summary-color-checkbox {
      display: flex;
      align-items: center;
      gap: 2px;
      margin-right: 6px;
      cursor: pointer;
      padding: 3px 5px;
      border-radius: 3px;
      transition: background-color 0.2s;
    }

    .annotations-summary-color-checkbox:hover {
      background-color: #f0f0f0;
    }

    .annotations-summary-color-checkbox input[type="checkbox"] {
      margin: 0 2px 0 0;
      accent-color: #007bff;
    }
  </style>
</head>
<body>
  <!-- NEW DOCK STRUCTURE -->
  <div id="bottom-left-dock">
    <div id="dock-info-stack">
      <div class="dock-column dock-labels-column">
        <div class="dock-stat-item-wrapper-progress">é˜…è¯»è¿›åº¦:</div>
        <div class="dock-stat-item-wrapper-highlight"><span class="stat-item-clickable" data-stat-type="highlight">é«˜äº®: <span id="highlight-count">0</span></span></div>
        <div class="dock-stat-item-wrapper-img">å›¾ç‰‡: <span id="image-count">0</span></div>
        <div class="dock-stat-item-wrapper-formula">å…¬å¼: <span id="formula-count">0</span></div>
      </div>
      <div class="dock-column dock-values-column">
        <div class="dock-stat-item-wrapper-progress"><span id="reading-progress-percentage-verbose">0</span>%</div>
        <div class="dock-stat-item-wrapper-annotation"><span class="stat-item-clickable" data-stat-type="annotation">æ‰¹æ³¨: <span id="annotation-count">0</span></span></div>
        <div class="dock-stat-item-wrapper-tbl">è¡¨æ ¼: <span id="table-count">0</span></div>
        <div class="dock-stat-item-wrapper-words">æ€»å­—æ•°: <span id="total-word-count">0</span></div>
      </div>
    </div>
    <span id="dock-collapsed-progress-display"><span id="reading-progress-percentage">0</span>%</span>
    <a href="#" id="settings-link" title="è®¾ç½®"><i class="fa fa-cog"></i></a>
    <a href="#" id="dock-toggle-btn" title="æŠ˜å "><i class="fa fa-chevron-down"></i></a>
  </div>

  <!-- ===================== -->
  <!-- æµ®åŠ¨TOCç›®å½•æŒ‰é’®åŠæ‚¬æµ®çª— -->
  <!-- ===================== -->
  <div id="toc-float-btn"><i class="fa fa-list"></i></div>
  <div id="toc-popup" class="toc-popup-hidden">
    <div id="toc-popup-header">
      <span><i class="fa fa-list"></i>ç›®å½• / TOC</span>
      <button id="toc-popup-close-btn">å…³é—­</button>
    </div>
    <ul id="toc-list"></ul>
  </div>

  <!-- ===================== -->
  <!-- ä¸»å†…å®¹å®¹å™¨ -->
  <!-- ===================== -->
  <div class="container">
    <h2 id="fileName">å†å²è¯¦æƒ…</h2>
    <div class="meta" id="fileMeta"></div>

    <!-- æ ‡ç­¾é¡µå¯¼èˆª -->
    <div class="tabs-container">
      <button class="tab-btn" id="tab-ocr">ä»…OCR</button>
      <button class="tab-btn" id="tab-translation">ä»…ç¿»è¯‘</button>
      <!-- <button class="tab-btn" id="tab-compare">å¯¹æ¯”</button> -->
      <button class="tab-btn" id="tab-chunk-compare">åˆ†å—å¯¹æ¯”</button>
    </div>
    <!-- æ ‡ç­¾é¡µå†…å®¹æ˜¾ç¤ºåŒºåŸŸ -->
    <div class="tab-content" id="tabContent"></div>
  </div>

  <!-- ===================== -->
  <!-- è‡ªå®šä¹‰ä¸Šä¸‹æ–‡èœå• -->
  <!-- ===================== -->
  <div id="custom-context-menu" class="context-menu-hidden">
    <ul>
      <li data-action="highlight-block">
        é«˜äº®æ­¤åŒºå—
        <div class="color-palette">
          <span class="color-option color-yellow" data-color="yellow" title="é»„è‰²"></span>
          <span class="color-option color-pink" data-color="pink" title="ç²‰è‰²"></span>
          <span class="color-option color-lightblue" data-color="lightblue" title="æµ…è“è‰²"></span>
          <span class="color-option color-lightgreen" data-color="lightgreen" title="æµ…ç»¿è‰²"></span>
          <span class="color-option color-purple" data-color="purple" title="ç´«è‰²"></span>
          <span class="color-option color-orange" data-color="orange" title="æ©™è‰²"></span>
        </div>
      </li>
      <li data-action="remove-highlight" id="remove-highlight-option" style="display: none;">å–æ¶ˆé«˜äº®</li>
      <hr class="menu-divider" id="highlight-actions-divider" style="display: none;">
      <li data-action="add-note" id="add-note-option" style="display: none;">æ·»åŠ æ‰¹æ³¨</li>
      <li data-action="edit-note" id="edit-note-option" style="display: none;">ç¼–è¾‘æ‰¹æ³¨</li>
      <hr class="menu-divider" id="note-actions-divider" style="display: none;">
      <li data-action="copy-content" id="copy-content-option"><i class="fa fa-copy"></i>å¤åˆ¶å†…å®¹</li>
      <!-- æ›´å¤šæ“ä½œå¯ä»¥åç»­æ·»åŠ  -->
    </ul>
  </div>

  <!-- Dock Settings Modal -->
  <div id="dock-settings-modal" class="dock-settings-modal modal-overlay"> <!-- Default: not visible -->
    <div class="dock-settings-modal-content modal-content"> <!-- ADDED modal-content class -->
      <span class="dock-settings-modal-close-btn" id="dock-settings-close-btn">&times;</span>
      <h2>æ˜¾ç¤ºè®¾ç½®</h2>
      <div class="checkbox-container"> <!-- Container for checkboxes -->
        <div class="checkbox-group">
          <input type="checkbox" id="ds-readingProgress" data-config-key="readingProgress">
          <label for="ds-readingProgress">é˜…è¯»è¿›åº¦</label>
        </div>
        <div class="checkbox-group">
          <input type="checkbox" id="ds-highlights" data-config-key="highlights">
          <label for="ds-highlights">é«˜äº®</label>
        </div>
        <div class="checkbox-group">
          <input type="checkbox" id="ds-annotations" data-config-key="annotations">
          <label for="ds-annotations">æ‰¹æ³¨</label>
        </div>
        <div class="checkbox-group">
          <input type="checkbox" id="ds-images" data-config-key="images">
          <label for="ds-images">å›¾ç‰‡</label>
        </div>
        <div class="checkbox-group">
          <input type="checkbox" id="ds-tables" data-config-key="tables">
          <label for="ds-tables">è¡¨æ ¼</label>
        </div>
        <div class="checkbox-group">
          <input type="checkbox" id="ds-formulas" data-config-key="formulas">
          <label for="ds-formulas">å…¬å¼</label>
        </div>
        <div class="checkbox-group">
          <input type="checkbox" id="ds-words" data-config-key="words">
          <label for="ds-words">æ€»å­—æ•°</label>
        </div>
      </div>

      <!-- æ–°å¢TOCæ˜¾ç¤ºæ¨¡å¼è®¾ç½®éƒ¨åˆ† -->
      <h3>ç›®å½•(TOC)è®¾ç½®</h3>
      <div class="radio-container">
        <div class="radio-group">
          <input type="radio" id="toc-mode-both" name="toc-mode" value="both" checked>
          <label for="toc-mode-both">åŒè¯­ç›®å½•</label>
        </div>
        <div class="radio-group">
          <input type="radio" id="toc-mode-ocr" name="toc-mode" value="ocr">
          <label for="toc-mode-ocr">ä»…åŸæ–‡ç›®å½•</label>
        </div>
        <div class="radio-group">
          <input type="radio" id="toc-mode-translation" name="toc-mode" value="translation">
          <label for="toc-mode-translation">ä»…è¯‘æ–‡ç›®å½•</label>
        </div>
      </div>

      <div class="dock-settings-modal-buttons">
        <button id="dock-settings-save-btn" class="btn btn-primary">ä¿å­˜</button>
        <button id="dock-settings-cancel-btn" class="btn btn-secondary">å–æ¶ˆ</button>
      </div>
    </div>
  </div>

  <!-- Annotations/Highlights Summary Modal -->
  <div id="annotations-summary-modal" class="modal-overlay"> <!-- Default: not visible via CSS -->
    <div class="modal-content">
      <span class="modal-close-btn" id="annotations-summary-close-btn">&times;</span>
      <h2 id="annotations-summary-title">æ‰¹æ³¨ä¸é«˜äº®è¯¦æƒ…</h2>
      <div class="annotations-summary-controls">
        <label for="annotations-filter-type">ç±»å‹:</label>
        <select id="annotations-filter-type">
          <option value="all">å…¨éƒ¨</option>
          <option value="highlighting">ä»…é«˜äº®</option>
          <option value="commenting">å¸¦æ‰¹æ³¨</option>
        </select>
        <label for="annotations-filter-content">å†…å®¹æ¥æº:</label>
        <select id="annotations-filter-content">
          <option value="all">å…¨éƒ¨ (OCR/ç¿»è¯‘)</option>
          <option value="ocr">ä»… OCR</option>
          <option value="translation">ä»…ç¿»è¯‘</option>
        </select>
        <div class="annotations-summary-color-filter" id="annotations-summary-color-filter">
          <!-- åŠ¨æ€æ’å…¥é¢œè‰²å¤šé€‰ -->
        </div>
      </div>
      <div class="table-container">
        <table id="annotations-summary-table">
          <thead>
            <tr>
              <th>ç±»å‹</th>
              <th>æ¥æº</th>
              <th>æ ‡è¯†ç¬¦</th>
              <th>æ–‡æœ¬ç‰‡æ®µ (é¢„è§ˆ)</th>
              <th>ç¬”è®°</th>
              <th>é¢œè‰²</th>
              <th>æ“ä½œ</th>
            </tr>
          </thead>
          <tbody id="annotations-summary-table-body">
            <!-- Rows will be populated by JavaScript -->
          </tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- ===================== -->
  <!-- ä¾èµ–çš„JSåº“ -->
  <!-- ===================== -->
  <script src="js/storage.js"></script>
  <script src="js/annotation_logic.js"></script>       <!-- Defines helpers like checkIfTextIsHighlighted -->
  <script src="js/custom_markdown_renderer.js"></script> <!-- Defines createCustomMarkdownRenderer -->
  <script src="js/annotation_highlighter.js"></script>   <!-- Defines applyPreprocessedAnnotations, uses helpers from annotation_logic.js -->
  <script src="js/toc_logic.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/html2pdf.js@0.10.1/dist/html2pdf.bundle.min.js"></script>
  <script src="js/mindmap.js"></script>

  <script src="js/chatbot/prompt-constructor.js"></script> <!-- Add this line -->
  <script src="js/chatbot/chatbot-utils.js"></script>
  <script src="js/chatbot/chatbot-preset.js"></script>
  <script src="js/chatbot/chatbot-core.js"></script>
  <script src="js/chatbot/chatbot-ui.js"></script>
  <script src="js/chatbot/chatbot.js"></script>
  <script src="js/dock_logic.js"></script>
  <script src="js/markdown_processor.js"></script>
  <script src="js/sub_block_segmenter.js"></script>
  <script src="js/dock_settings_modal.js"></script> <!-- ADDED -->
  <script src="js/annotations_summary_modal.js"></script> <!-- ADDED -->

  <!-- ===================== -->
  <!-- é¡µé¢æ ¸å¿ƒé€»è¾‘è„šæœ¬ -->
  <!-- ===================== -->
  <script>
    let isOriginalFirstInChunkCompare = true; // çŠ¶æ€å˜é‡ï¼šåŸæ–‡æ˜¯å¦åœ¨å·¦ä¾§
    let docIdForLocalStorage = null; // To store the current document ID for localStorage keys
    window.docIdForLocalStorage = null; // å°†å˜é‡æŒ‚è½½åˆ° window å¯¹è±¡ä¸Šï¼Œä½¿å…¶æˆä¸ºå…¨å±€å˜é‡
    var currentVisibleTabId = null;  // To store the ID of the currently visible tab
    window.currentVisibleTabId = null; // å°†å˜é‡æŒ‚è½½åˆ° window å¯¹è±¡ä¸Šï¼Œä½¿å…¶æˆä¸ºå…¨å±€å˜é‡
    // let progressPercentageSpan = null; // MOVED to dock_logic.js
    // let progressPercentageVerboseSpan = null; // MOVED to dock_logic.js
    // let dockElement = null; // MOVED to dock_logic.js

    // NEW FUNCTION DEFINITION
    function adjustLongHeadingsToParagraphs(parentElement) {
      if (!parentElement) return;

      // Only process headings within elements having 'markdown-body' class
      const markdownBodies = parentElement.querySelectorAll('.markdown-body');

      markdownBodies.forEach(markdownBody => {
        const headings = markdownBody.querySelectorAll('h1, h2, h3, h4, h5, h6');
        headings.forEach(heading => {
          // Skip the main fileName heading if it's somehow caught by this logic
          if (heading.id === 'fileName') {
              return;
          }

          const textContent = heading.textContent || "";
          if (textContent.length > 30) {
            const p = document.createElement('p');

            // Move all child nodes from heading to p
            while (heading.firstChild) {
              p.appendChild(heading.firstChild);
            }

            // Copy all attributes from heading to p
            for (let i = 0; i < heading.attributes.length; i++) {
              const attr = heading.attributes[i];
              p.setAttribute(attr.name, attr.value);
            }

            // Add a class to indicate this was a converted heading,
            // in case specific styling is needed later.
            p.classList.add('converted-from-heading');

            // Replace the heading with the new paragraph element in the DOM
            if (heading.parentNode) {
              heading.parentNode.replaceChild(p, heading);
            }
          }
        });
      });
    }

    function debounce(func, delay) {
      let timeout;
      return function(...args) {
        const context = this;
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(context, args), delay);
      };
    }

    function saveScrollPosition() {
      if (!docIdForLocalStorage || !currentVisibleTabId) return;
      const scrollableElement = document.documentElement; // Changed from .container
      if (scrollableElement) {
        const scrollKey = `scrollPos_${docIdForLocalStorage}_${currentVisibleTabId}`;
        localStorage.setItem(scrollKey, scrollableElement.scrollTop);
        // console.log(`Saved scroll for ${scrollKey} on documentElement: ${scrollableElement.scrollTop}`);
      }
    }
    // const debouncedSaveScrollPosition = debounce(saveScrollPosition, 300); // Debounce with 300ms
    const debouncedSaveScrollPosition = debounce(saveScrollPosition, 300); // å–æ¶ˆæ³¨é‡Šï¼Œä¿®å¤é—®é¢˜

    function saveChatbotStateOnUnload() {
      if (docIdForLocalStorage && typeof window.isChatbotOpen !== 'undefined') {
        localStorage.setItem(`chatbotOpenState_${docIdForLocalStorage}`, window.isChatbotOpen);
        // console.log(`Saved chatbot state on beforeunload for ${docIdForLocalStorage}: ${window.isChatbotOpen}`);
      }
    }

    // MOVED to dock_logic.js: function updateReadingProgress() { ... }
    // MOVED to dock_logic.js: const debouncedUpdateReadingProgress = debounce(updateReadingProgress, 100);

    // MOVED to dock_logic.js: function updateHighlightSummary() { ... }
    // MOVED to dock_logic.js: function updateAnnotationSummary() { ... }
    // MOVED to dock_logic.js: function updateImageCount() { ... }
    // MOVED to dock_logic.js: function updateTableCount(contentElement) { ... }
    // MOVED to dock_logic.js: function updateFormulaCount(contentElement) { ... }
    // MOVED to dock_logic.js: function updateWordCount(contentElement) { ... }
    // MOVED to dock_logic.js: function updateAllDockStats() { ... }

    /**
     * é¢„å¤„ç† Markdown æ–‡æœ¬ï¼Œä»¥å®‰å…¨åœ°æ¸²æŸ“å›¾ç‰‡ã€è‡ªå®šä¹‰è¯­æ³•ï¼ˆå¦‚ä¸Šä¸‹æ ‡ï¼‰å¹¶å…¼å®¹ KaTeXã€‚
     * - å°† Markdown ä¸­çš„æœ¬åœ°å›¾ç‰‡å¼•ç”¨ (e.g., `![alt](images/img-1.jpeg.png)`) æ›¿æ¢ä¸º Base64 åµŒå…¥å¼å›¾ç‰‡ã€‚
     * - è§£æè‡ªå®šä¹‰çš„ä¸Šä¸‹æ ‡è¯­æ³• (e.g., `${base}^{sup}$`, `${base}_{sub}$`) å¹¶è½¬æ¢ä¸º HTML `<sup>` å’Œ `<sub>` æ ‡ç­¾ã€‚
     * - å…¶ä»–å¦‚ `$formula$` å’Œ `$$block formula$$` çš„ LaTeX æ ‡è®°ä¼šä¿ç•™ï¼Œäº¤ç”±åç»­çš„ `renderWithKatexFailback` å¤„ç†ã€‚
     *
     * @param {string} md -è¾“å…¥çš„ Markdown æ–‡æœ¬ã€‚
     * @param {Array<Object>} images -ä¸€ä¸ªåŒ…å«å›¾ç‰‡å¯¹è±¡çš„æ•°ç»„ï¼Œæ¯ä¸ªå¯¹è±¡åº”æœ‰ `name` æˆ– `id` (ç”¨äºåŒ¹é…) å’Œ `data` (Base64 å›¾ç‰‡æ•°æ®æˆ–å…¶å‰ç¼€)ã€‚
     * @returns {string} å¤„ç†åçš„ Markdown æ–‡æœ¬ï¼Œå…¶ä¸­å›¾ç‰‡è¢«æ›¿æ¢ï¼Œè‡ªå®šä¹‰è¯­æ³•è¢«è½¬æ¢ã€‚
     */
    // MOVED to js/markdown_processor.js: function safeMarkdown(md, images) { ... }

    /**
     * ä½¿ç”¨ KaTeX æ¸²æŸ“ Markdown æ–‡æœ¬ä¸­çš„æ•°å­¦å…¬å¼ï¼Œå¹¶æä¾›é™çº§å¤„ç†ã€‚
     * å®ƒä¼šæŒ‰ä»¥ä¸‹é¡ºåºå¤„ç†ï¼š
     * 1. å°†é•¿åº¦è¾ƒçŸ­ (<=10å­—ç¬¦) çš„å—çº§å…¬å¼ `$$...$$` è½¬æ¢ä¸ºè¡Œå†…å…¬å¼ `$...\$`ã€‚
     * 2. å°è¯•ä½¿ç”¨ KaTeX æ¸²æŸ“è¡Œå†…å…¬å¼ `$...\$`ã€‚å¦‚æœæ¸²æŸ“å¤±è´¥ï¼Œåˆ™å°†å…¬å¼å†…å®¹åŒ…è£¹åœ¨ `<code>` æ ‡ç­¾ä¸­æ˜¾ç¤ºã€‚
     * 3. å°è¯•ä½¿ç”¨ KaTeX æ¸²æŸ“å‰©ä½™çš„ï¼ˆé€šå¸¸æ˜¯å¤šè¡Œçš„ï¼‰å—çº§å…¬å¼ `$$...$$`ã€‚å¦‚æœæ¸²æŸ“å¤±è´¥ï¼Œåˆ™åŒæ ·åŒ…è£¹åœ¨ `<code>` æ ‡ç­¾ä¸­ã€‚
     * 4. å¯¹å¤„ç†å®Œå…¬å¼çš„æ–‡æœ¬ï¼Œä½¿ç”¨ `marked.parse()` å°†å…¶ä½™ Markdown å†…å®¹è½¬æ¢ä¸º HTMLã€‚
     *
     * @param {string} md - ç»è¿‡ `safeMarkdown` å¤„ç†çš„ Markdown æ–‡æœ¬ã€‚
     * @param {Function} customRenderer - è‡ªå®šä¹‰çš„ Markdown æ¸²æŸ“å™¨å‡½æ•°ï¼Œç”¨äºå¤„ç†ç‰¹æ®Šå†…å®¹ã€‚
     * @returns {string} åŒ…å«æ¸²æŸ“åå…¬å¼å’Œå…¶ä½™ Markdown å†…å®¹çš„ HTML å­—ç¬¦ä¸²ã€‚
     */
    // MOVED to js/markdown_processor.js: function renderWithKatexFailback(md, customRenderer) { ... }

    /**
     * ä»å½“å‰é¡µé¢çš„ URL ä¸­è·å–æŒ‡å®šæŸ¥è¯¢å‚æ•°çš„å€¼ã€‚
     * @param {string} name - è¦è·å–çš„æŸ¥è¯¢å‚æ•°çš„åç§°ã€‚
     * @returns {string|null} æŸ¥è¯¢å‚æ•°çš„å€¼ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™è¿”å› nullã€‚
     */
    function getQueryParam(name) {
      const url = new URL(window.location.href);
      return url.searchParams.get(name);
    }
    /**
     * @type {Object|null}
     * @description å­˜å‚¨ä» IndexedDB åŠ è½½çš„å½“å‰å†å²è®°å½•çš„è¯¦ç»†æ•°æ®ã€‚
     */
    let data = null;

    /**
     * å°†å—çº§å…ƒç´ å†…å®¹æŒ‰æ ‡ç‚¹åˆ†å‰²æˆå­å— (span.sub-block)ã€‚
     * @param {HTMLElement} blockElement - è¦åˆ†å‰²çš„å—çº§å…ƒç´  (å¦‚ p, h1-h6)ã€‚
     * @param {string|number} parentBlockIndex - çˆ¶å—çš„ç´¢å¼•ã€‚
     */
    // MOVED to js/sub_block_segmenter.js: function segmentBlockIntoSubBlocks(blockElement, parentBlockIndex) { ... }

    /**
     * å¼‚æ­¥æ¸²æŸ“å†å²è¯¦æƒ…é¡µé¢çš„ä¸»å‡½æ•°ã€‚
     * - ä» URL æŸ¥è¯¢å‚æ•°ä¸­è·å–è®°å½• IDã€‚
     * - ä½¿ç”¨ `getResultFromDB` (æ¥è‡ª storage.js) ä» IndexedDB åŠ è½½å¯¹åº”çš„å†å²æ•°æ®ã€‚
     * - å¦‚æœæ•°æ®æˆåŠŸåŠ è½½ï¼š
     *   - æ›´æ–°é¡µé¢æ ‡é¢˜ (`#fileName`) å’Œå…ƒæ•°æ® (`#fileMeta`)ã€‚
     *   - æ ¹æ®æ•°æ®ä¸­æ˜¯å¦å­˜åœ¨æœ‰æ•ˆçš„åˆ†å—ä¿¡æ¯ (`ocrChunks`, `translatedChunks`)ï¼Œ
     *     å†³å®šé»˜è®¤æ˜¾ç¤ºçš„æ ‡ç­¾é¡µï¼ˆä¼˜å…ˆæ˜¾ç¤ºåˆ†å—å¯¹æ¯”ï¼Œå¦åˆ™æ˜¾ç¤º OCR å†…å®¹ï¼‰ã€‚
     * - å¦‚æœæœªæ‰¾åˆ°æ•°æ®ï¼Œåˆ™æ˜¾ç¤ºæç¤ºä¿¡æ¯ã€‚
     * @async
     */
    async function renderDetail() {
      const id = getQueryParam('id');
      if (!id) return;
      docIdForLocalStorage = id; // Store doc ID for localStorage operations
      window.docIdForLocalStorage = id; // åŒæ—¶æ›´æ–°æŒ‚è½½åˆ° window å¯¹è±¡ä¸Šçš„å˜é‡

      // Restore chatbot open state
      const savedChatbotOpenState = localStorage.getItem(`chatbotOpenState_${docIdForLocalStorage}`);
      if (savedChatbotOpenState === 'true') {
        window.isChatbotOpen = true;
      } else if (savedChatbotOpenState === 'false') {
        window.isChatbotOpen = false;
      }

      // ä»localStorageæ¢å¤ä¿å­˜çš„æ¯”ä¾‹è®¾ç½®
      const savedChunkCompareRatio = localStorage.getItem(`chunkCompareRatio_${docIdForLocalStorage}`);
      if (savedChunkCompareRatio !== null && !isNaN(parseFloat(savedChunkCompareRatio))) {
        window.chunkCompareRatio = parseFloat(savedChunkCompareRatio);
      }

      // console.log(`Chatbot state after attempting restore from localStorage for ${docIdForLocalStorage}: ${window.isChatbotOpen}`);

      // Initialize Dock Logic once docIdForLocalStorage is available
      if (typeof window.DockLogic !== 'undefined' && typeof window.DockLogic.init === 'function') {
        window.DockLogic.init(docIdForLocalStorage);
      } else {
        console.error("DockLogic not available or init function missing.");
      }

      data = await getResultFromDB(id);
      window.data = data; // for debugging
      if (!data) {
        document.getElementById('fileName').textContent = 'æœªæ‰¾åˆ°æ•°æ®';
        document.getElementById('fileMeta').textContent = '';
        document.getElementById('tabContent').innerHTML = '';
        return;
      }
      document.getElementById('fileName').textContent = data.name;
      document.getElementById('fileMeta').innerHTML = `æ—¶é—´: ${new Date(data.time).toLocaleString()} &nbsp; | &nbsp; å›¾ç‰‡æ•°: ${data.images ? data.images.length : 0}`;

      // ========== ç¡®ä¿æ‰¹æ³¨æ•°æ®åœ¨æ¸²æŸ“å‰åŠ è½½ ==========
      if (id) { // ç¡®ä¿æˆ‘ä»¬æœ‰æ–‡æ¡£ ID
        try {
          const annotations = await getAnnotationsForDocFromDB(id);
          console.log(`Annotations for docId '${id}' (loaded in renderDetail):`, annotations);
          data.annotations = annotations || []; // å­˜å‚¨åˆ° data å¯¹è±¡ï¼Œç¡®ä¿æ˜¯æ•°ç»„
          // updateAnnotationSummary(); // Handled by updateAllDockStats via showTab
          // updateHighlightSummary(); // Handled by updateAllDockStats via showTab
        } catch (error) {
          console.error(`Error loading annotations for docId '${id}' in renderDetail:`, error);
          data.annotations = []; // å‡ºé”™æ—¶ä¹Ÿç¡®ä¿æ˜¯ä¸ªç©ºæ•°ç»„
          // updateAnnotationSummary(); // Handled by updateAllDockStats via showTab
          // updateHighlightSummary(); // Handled by updateAllDockStats via showTab
        }
      } else {
        // updateAnnotationSummary(); // Handled by updateAllDockStats via showTab
        // updateHighlightSummary(); // Handled by updateAllDockStats via showTab
      }
      // =============================================

      // ========== åœ¨ window.data è®¾ç½®å¹¶å¡«å……æ‰¹æ³¨åï¼Œæ˜¾å¼åŠ è½½èŠå¤©è®°å½• ==========
      if (window.data) {
        if (window.ChatbotCore && typeof window.ChatbotCore.reloadChatHistoryAndUpdateUI === 'function' &&
            window.ChatbotUI && typeof window.ChatbotUI.updateChatbotUI === 'function') {
          console.log('renderDetail: Calling reloadChatHistoryAndUpdateUI after window.data and annotations are set. Current docId:', window.ChatbotCore.getCurrentDocId ? window.ChatbotCore.getCurrentDocId() : 'unknown');
          window.ChatbotCore.reloadChatHistoryAndUpdateUI(window.ChatbotUI.updateChatbotUI);
        } else {
          console.error('renderDetail: ChatbotCore or ChatbotUI not fully available for history reload.');
        }
      }
      // =================================================================

      // Initialize annotation system after data is loaded and DOM is likely ready
      if (typeof window.initializeGlobalAnnotationVariables === 'function') {
        window.initializeGlobalAnnotationVariables();
      }
      if (typeof window.initAnnotationSystem === 'function') {
        window.initAnnotationSystem();
      } else {
        console.error("initAnnotationSystem is not defined. Check js/annotation_logic.js");
      }

      // Determine initial tab, AFTER annotations are loaded
      let initialTab = 'ocr'; // Default tab
      if (docIdForLocalStorage) {
        const savedTabKey = `activeTab_${docIdForLocalStorage}`;
        const savedTab = localStorage.getItem(savedTabKey);
        if (savedTab && ['ocr', 'translation', 'chunk-compare'].includes(savedTab)) {
          initialTab = savedTab;
        } else if (data.ocrChunks && data.ocrChunks.length > 0 && data.translatedChunks && data.translatedChunks.length > 0 && data.ocrChunks.length === data.translatedChunks.length) {
           initialTab = 'chunk-compare';
        }
      } else if (data.ocrChunks && data.ocrChunks.length > 0 && data.translatedChunks && data.translatedChunks.length > 0 && data.ocrChunks.length === data.translatedChunks.length) {
        initialTab = 'chunk-compare';
      }

      // ç°åœ¨ï¼Œåœ¨æ‰¹æ³¨è‚¯å®šåŠ è½½å®Œæ¯•åï¼Œæ‰è°ƒç”¨ showTab
      showTab(initialTab);

      // The block for loading annotations (previously around line 415) has been moved up.

      // Add scroll listener for saving scroll position
      window.removeEventListener('scroll', debouncedSaveScrollPosition);
      window.addEventListener('scroll', debouncedSaveScrollPosition);
      // Add scroll listener for updating reading progress - MOVED TO DOCK_LOGIC.JS
      // window.removeEventListener('scroll', debouncedUpdateReadingProgress);
      // window.addEventListener('scroll', debouncedUpdateReadingProgress);

      // Add listener to save chatbot state on page unload
      window.removeEventListener('beforeunload', saveChatbotStateOnUnload);
      window.addEventListener('beforeunload', saveChatbotStateOnUnload);

      // Manage Annotations Link Click - Changed to Settings Link - MOVED TO DOCK_LOGIC.JS
      // const settingsLink = document.getElementById('settings-link');
      // if (settingsLink) {
      //   settingsLink.onclick = function(event) {
      //     event.preventDefault();
      //     alert('ç®¡ç†é¡µé¢å³å°†æ¨å‡ºï¼'); // Updated alert message
      //   };
      // }

      // Dock Toggle Button Click - MOVED TO DOCK_LOGIC.JS
      // const dockToggleBtn = document.getElementById('dock-toggle-btn');
      // const dock = document.getElementById('bottom-left-dock');
      // if (dockToggleBtn && dock) {
      //   // Restore collapsed state
      //   const dockCollapsedKey = `dockCollapsed_${docIdForLocalStorage}`;
      //   const isCollapsed = localStorage.getItem(dockCollapsedKey) === 'true';
      //   if (isCollapsed) {
      //     dock.classList.add('dock-collapsed');
      //     dockToggleBtn.innerHTML = '<i class="fa fa-chevron-up"></i>';
      //     dockToggleBtn.title = 'å±•å¼€';
      //   }

      //   dockToggleBtn.onclick = function(event) {
      //     event.preventDefault();
      //     const currentlyCollapsed = dock.classList.toggle('dock-collapsed');
      //     if (currentlyCollapsed) {
      //       this.innerHTML = '<i class="fa fa-chevron-up"></i>';
      //       this.title = 'å±•å¼€';
      //       localStorage.setItem(dockCollapsedKey, 'true');
      //     } else {
      //       this.innerHTML = '<i class="fa fa-chevron-down"></i>';
      //       this.title = 'æŠ˜å ';
      //       localStorage.setItem(dockCollapsedKey, 'false');
      //     }
      //   };
      // }
    }

    /**
     * åˆ‡æ¢å¹¶æ˜¾ç¤ºæŒ‡å®šçš„æ ‡ç­¾é¡µå†…å®¹ã€‚
     * - æ›´æ–°æ ‡ç­¾æŒ‰é’®çš„æ¿€æ´»çŠ¶æ€ (`active` class)ã€‚
     * - æ ¹æ®ä¼ å…¥çš„ `tab` å‚æ•° ( 'ocr', 'translation', 'chunk-compare' )ï¼Œç”Ÿæˆå¯¹åº”çš„ HTML å†…å®¹ã€‚
     * - OCR å’Œç¿»è¯‘æ ‡ç­¾é¡µï¼šç›´æ¥æ¸²æŸ“ `data.ocr` æˆ– `data.translation` å­—æ®µã€‚
     * - åˆ†å—å¯¹æ¯”æ ‡ç­¾é¡µ (`chunk-compare`)ï¼š
     *   - æ£€æŸ¥ `data.ocrChunks` å’Œ `data.translatedChunks` æ˜¯å¦æœ‰æ•ˆä¸”æ•°é‡åŒ¹é…ã€‚
     *   - å¦‚æœæœ‰æ•ˆï¼Œåˆ™ä¸ºæ¯ä¸€å¯¹åŸæ–‡/è¯‘æ–‡å—ç”Ÿæˆå¯¹æ¯”è§†å›¾ã€‚ä½¿ç”¨ `renderLevelAlignedFlex` è¿›è¡Œå¸ƒå±€ã€‚
     *   - æä¾›ä¸€ä¸ªæŒ‰é’® (`#swap-chunks-btn`) ç”¨äºåˆ‡æ¢åŸæ–‡å’Œè¯‘æ–‡åœ¨å¯¹æ¯”è§†å›¾ä¸­çš„å·¦å³ä½ç½®ã€‚
     *   - å¦‚æœåˆ†å—æ•°æ®æ— æ•ˆï¼Œåˆ™æ˜¾ç¤ºæç¤ºä¿¡æ¯ã€‚
     * - å°†ç”Ÿæˆçš„ HTML è®¾ç½®åˆ° `#tabContent` åŒºåŸŸã€‚
     * - è°ƒç”¨ `window.refreshTocList()` æ›´æ–°ç›®å½•ï¼ˆTOCï¼‰ã€‚
     *
     * @param {string} tab - è¦æ˜¾ç¤ºçš„æ ‡ç­¾é¡µæ ‡è¯†ç¬¦ ('ocr', 'translation', or 'chunk-compare')ã€‚
     */
    function showTab(tab) {
      currentVisibleTabId = tab; // Update global current tab ID
      window.currentVisibleTabId = tab; // åŒæ—¶æ›´æ–°æŒ‚è½½åˆ° window å¯¹è±¡ä¸Šçš„å˜é‡
      window.currentBlockTokensForCopy = window.currentBlockTokensForCopy || {}; // Initialize if not exists

      // æ ¹æ® tab å‚æ•°ç«‹å³è®¾ç½®å…¨å±€å†…å®¹æ ‡è¯†ç¬¦
      if (tab === 'ocr') {
        window.globalCurrentContentIdentifier = 'ocr';
      } else if (tab === 'translation') {
        window.globalCurrentContentIdentifier = 'translation';
      } else {
        window.globalCurrentContentIdentifier = ''; // ä¾‹å¦‚åˆ†å—å¯¹æ¯”æˆ–å…¶ä»–æ ‡ç­¾é¡µ
      }

      if (docIdForLocalStorage) {
        const activeTabKey = `activeTab_${docIdForLocalStorage}`;
        localStorage.setItem(activeTabKey, tab);
        // console.log(`Saved active tab for ${docIdForLocalStorage}: ${tab}`);
      }

      document.getElementById('tab-ocr').classList.remove('active');
      document.getElementById('tab-translation').classList.remove('active');
      // document.getElementById('tab-compare').classList.remove('active'); // å¯¹åº”æŒ‰é’®å·²æ³¨é‡Šï¼Œæ­¤è¡Œä¹Ÿå¯æ³¨é‡Š
      document.getElementById('tab-chunk-compare').classList.remove('active');

      let html = '';
      let contentContainerId = ''; // ç”¨äº applyAnnotationsToContent
      let activeContentElement = null; // ç”¨äº applyAnnotationsToContent
      const significantTokenTypes = ['paragraph', 'heading', 'code', 'table', 'blockquote', 'list', 'html', 'hr'];

      // ---- å¢åŠ æ—¥å¿— ----
      // æ—¥å¿—ç°åœ¨å¯ä»¥å‡†ç¡®åæ˜  globalCurrentContentIdentifier
      console.log(`[showTab - ${tab}] å³å°†æ¸²æŸ“ã€‚å½“å‰ window.globalCurrentContentIdentifier:`, window.globalCurrentContentIdentifier);
      if (data && data.annotations) {
          console.log(`[showTab - ${tab}] data.annotations (é•¿åº¦ ${data.annotations.length}):`, JSON.parse(JSON.stringify(data.annotations)));
      } else {
          console.log(`[showTab - ${tab}] data.annotations ä¸å¯ç”¨æˆ–ä¸ºç©ºã€‚`);
      }
      // ---- æ—¥å¿—ç»“æŸ ----

      if(tab === 'ocr') {
        document.getElementById('tab-ocr').classList.add('active');
        contentContainerId = 'ocr-content-wrapper';
        let ocrText = data.ocr || '';
        const ocrLexerTokens = marked.lexer(ocrText);
        window.currentBlockTokensForCopy['ocr'] = ocrLexerTokens.filter(token => significantTokenTypes.includes(token.type));
        const ocrCustomRenderer = createCustomMarkdownRenderer(data.annotations, 'ocr', MarkdownProcessor.renderWithKatexFailback); // MODIFIED
        const ocrContentHTML = MarkdownProcessor.renderWithKatexFailback(MarkdownProcessor.safeMarkdown(ocrText, data.images), ocrCustomRenderer); // MODIFIED
        html = `<h3>OCRå†…å®¹</h3><div id="${contentContainerId}" class="markdown-body content-wrapper">${ocrContentHTML}</div>`;
      } else if(tab === 'translation') {
        document.getElementById('tab-translation').classList.add('active');
        contentContainerId = 'translation-content-wrapper';
        let transText = data.translation || '';
        const transLexerTokens = marked.lexer(transText);
        window.currentBlockTokensForCopy['translation'] = transLexerTokens.filter(token => significantTokenTypes.includes(token.type));
        const translationCustomRenderer = createCustomMarkdownRenderer(data.annotations, 'translation', MarkdownProcessor.renderWithKatexFailback); // MODIFIED
        const translationContentHTML = MarkdownProcessor.renderWithKatexFailback(MarkdownProcessor.safeMarkdown(transText, data.images), translationCustomRenderer); // MODIFIED
        html = `<h3>ç¿»è¯‘å†…å®¹</h3><div id="${contentContainerId}" class="markdown-body content-wrapper">${translationContentHTML}</div>`;
      } else if (tab === 'chunk-compare') {
        // window.globalCurrentContentIdentifier = ''; // å·²åœ¨å‡½æ•°å¼€å¤´æ­£ç¡®è®¾ç½®
        document.getElementById('tab-chunk-compare').classList.add('active');
        if (data.ocrChunks && data.ocrChunks.length > 0 && data.translatedChunks && data.translatedChunks.length === data.ocrChunks.length) {
            html = `
              <div class="chunk-compare-title-bar">
                <h3>åˆ†å—å¯¹æ¯”</h3>
                <button id="swap-chunks-btn" title="åˆ‡æ¢åŸæ–‡/è¯‘æ–‡ä½ç½®">â‡†</button>
              </div>
              <div class="chunk-compare-container">
            `;
            /**
             * è§£æMarkdownæ–‡æœ¬ä¸ºé€»è¾‘å—æ•°ç»„ï¼Œä¸»è¦åŸºäºæ ‡é¢˜è¿›è¡Œåˆ†å‰²ã€‚
             * ä»£ç å— (```...```) ä¼šè¢«è§†ä¸ºå•ä¸ªå—çš„ä¸€éƒ¨åˆ†ï¼Œä¸ä¼šè¢«åˆ†å‰²ã€‚
             * @param {string} md - Markdownæ–‡æœ¬ã€‚
             * @returns {Array<Object>} æ¯ä¸ªå¯¹è±¡åŒ…å« `{ content: string }`ã€‚
             */
            function parseMarkdownBlocks(md) {
              const lines = (md || '').split(/\r?\n/);
              const blocks = [];
              let buffer = [];
              let inCode = false;
              let isFirstBlock = true;
              function flush() {
                if (buffer.length) {
                  blocks.push({ content: buffer.join('\n') });
                  buffer = [];
                }
              }
              for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                if (/^\s*```/.test(line)) { // ä»£ç å—
                  inCode = !inCode;
                  buffer.push(line);
                  continue;
                }
                if (inCode) {
                  buffer.push(line);
                  continue;
                }
                if (/^\s*#/.test(line)) { // æ ‡é¢˜ä½œä¸ºæ–°åˆ†å—çš„èµ·ç‚¹
                  if (!isFirstBlock) flush();
                  isFirstBlock = false;
                  buffer.push(line);
                  continue;
                }
                // æ™®é€šå†…å®¹ã€åˆ—è¡¨ã€ç©ºè¡Œç­‰éƒ½åˆå¹¶åˆ°å½“å‰å—
                buffer.push(line);
              }
              flush();
              return blocks;
            }
            /**
             * å¯¹é½ä¸¤ç»„Markdowné€»è¾‘å—ï¼Œç”¨äºå¹¶æ’æ˜¾ç¤ºã€‚
             * ç®€å•åœ°æŒ‰ç´¢å¼•é€ä¸ªé…å¯¹ï¼Œå¦‚æœæŸä¸€ç»„å—å°‘ï¼Œåˆ™å¯¹åº”ä½ç½®ä¸ºç©ºå­—ç¬¦ä¸²ã€‚
             * @param {Array<Object>} blocks1 - ç¬¬ä¸€ç»„å—ã€‚
             * @param {Array<Object>} blocks2 - ç¬¬äºŒç»„å—ã€‚
             * @returns {Array<Array<string>>} æ¯ä¸ªå†…éƒ¨æ•°ç»„åŒ…å«ä¸¤ä¸ªå­—ç¬¦ä¸² `[block1_content, block2_content]`ã€‚
             */
            function alignBlocks(blocks1, blocks2) {
              // ç®€å•æŒ‰ç±»å‹å’Œé¡ºåºå¯¹é½
              const maxLen = Math.max(blocks1.length, blocks2.length);
              const aligned = [];
              for (let i = 0; i < maxLen; i++) {
                aligned.push([
                  blocks1[i] ? blocks1[i].content : '',
                  blocks2[i] ? blocks2[i].content : ''
                ]);
              }
              return aligned;
            }
            /**
             * æ¸²æŸ“å•ä¸ªOCRå—å’Œå…¶å¯¹åº”çš„ç¿»è¯‘å—çš„å¯¹é½è§†å›¾ï¼Œæ”¯æŒåˆ†å±‚ç»“æ„ã€‚
             * - å®ƒé¦–å…ˆä½¿ç”¨ `parseMarkdownBlocks` å°†OCRå’Œç¿»è¯‘æ–‡æœ¬åˆ†å‰²æˆå°å—ï¼ˆåŸºäºæ ‡é¢˜ï¼‰ã€‚
             * - ç„¶åä½¿ç”¨ `alignBlocks` å¯¹é½è¿™äº›å°å—ã€‚
             * - ä¸ºæ¯ä¸ªå¯¹é½çš„å°å—å¯¹ç”Ÿæˆå¹¶æ’çš„HTMLç»“æ„ï¼Œç”¨äºæ˜¾ç¤ºåŸæ–‡å’Œè¯‘æ–‡ã€‚
             * - æä¾›å·¥å…·æ æŒ‰é’®ï¼Œç”¨äºåˆ‡æ¢æ˜¾ç¤ºæ¨¡å¼ï¼ˆå¯¹æ¯”ã€ä»…åŸæ–‡ã€ä»…è¯‘æ–‡ï¼‰ã€å¤åˆ¶æ•´å—å†…å®¹ä»¥åŠå¯¼èˆªåˆ°ä¸Šä¸‹å—ã€‚
             * - åŸå§‹å—å†…å®¹å­˜å‚¨åœ¨ `window.blockRawContent_[blockIndex]` ä¸­ï¼Œä¾›å¤åˆ¶åŠŸèƒ½ä½¿ç”¨ã€‚
             *
             * @param {string} ocrChunk - OCRæ–‡æœ¬å—ã€‚
             * @param {string} translatedChunk - å¯¹åº”çš„ç¿»è¯‘æ–‡æœ¬å—ã€‚
             * @param {Array<Object>} images - ä¸æ­¤æ–‡æ¡£å…³è”çš„å›¾ç‰‡æ•°æ®ã€‚
             * @param {number} blockIndex - å½“å‰å¤§å—åœ¨æ•´ä¸ªæ–‡æ¡£åˆ†å—ä¸­çš„ç´¢å¼•ã€‚
             * @param {number} totalBlocks - æ–‡æ¡£åˆ†å—çš„æ€»æ•°ã€‚
             * @returns {string} ç”Ÿæˆçš„HTMLå­—ç¬¦ä¸²ï¼Œç”¨äºæ˜¾ç¤ºå¯¹é½çš„å—å†…å®¹ã€‚
             */
            function renderLevelAlignedFlex(ocrChunk, translatedChunk, images, blockIndex, totalBlocks) {
              const ocrBlocks = parseMarkdownBlocks(ocrChunk);
              const transBlocks = parseMarkdownBlocks(translatedChunk);
              const aligned = alignBlocks(ocrBlocks, transBlocks);
              let showMode = window[`showMode_block_${blockIndex}`] || 'both';

              // åœ¨åˆ†å—å¯¹æ¯”å†…éƒ¨ä¹Ÿå°è¯•ä½¿ç”¨è‡ªå®šä¹‰æ¸²æŸ“å™¨
              // æ³¨æ„ï¼šè¿™é‡Œçš„ annotations åº”è¯¥æ˜¯æ•´ä¸ªæ–‡æ¡£çš„ï¼ŒcontentIdentifier éœ€è¦æ ¹æ®å½“å‰å—æ˜¯åŸæ–‡è¿˜æ˜¯è¯‘æ–‡æ¥ç¡®å®š
              // ä¸ºäº†ç®€åŒ–ï¼Œæˆ‘ä»¬æš‚æ—¶å‡è®¾åˆ†å—å¯¹æ¯”ä¸­çš„å†…å®¹ä¸ç›´æ¥å‚ä¸è¿™ç§ç²¾ç»†çš„é¢„æ ‡æ³¨ï¼Œ
              // æˆ–è€…éœ€è¦æ›´å¤æ‚çš„é€»è¾‘æ¥ä¼ é€’æ­£ç¡®çš„ contentIdentifier
              // MODIFIED: Pass empty array for annotations in chunk-compare mode to disable highlights/annotations
              const annotationsForChunkRender = [];
              const ocrRenderer = createCustomMarkdownRenderer(annotationsForChunkRender, 'ocr', MarkdownProcessor.renderWithKatexFailback);
              const transRenderer = createCustomMarkdownRenderer(annotationsForChunkRender, 'translation', MarkdownProcessor.renderWithKatexFailback);

              // æ•´å—å¤åˆ¶æŒ‰é’®
              let html = `
                <div class="block-toolbar" data-block-toolbar="${blockIndex}">
                  <div class="block-toolbar-left">
                    <span class="block-mode-btn ${showMode === 'both' ? 'active' : ''}" data-mode="both" data-block="${blockIndex}">å¯¹æ¯”</span>
                    <span class="block-mode-btn ${showMode === 'ocr' ? 'active' : ''}" data-mode="ocr" data-block="${blockIndex}">åŸæ–‡</span>
                    <span class="block-mode-btn ${showMode === 'trans' ? 'active' : ''}" data-mode="trans" data-block="${blockIndex}">è¯‘æ–‡</span>
                    <button class="block-copy-btn" data-block="${blockIndex}" title="å¤åˆ¶æœ¬å—å†…å®¹">å¤åˆ¶æœ¬å—</button>
                  </div>
                  <div class="block-toolbar-right">
                    ${blockIndex > 0 ? `<button class="block-nav-btn" data-dir="prev" data-block="${blockIndex}" title="ä¸Šä¸€æ®µ">â†‘</button>` : ''}
                    ${blockIndex < totalBlocks-1 ? `<button class="block-nav-btn" data-dir="next" data-block="${blockIndex}" title="ä¸‹ä¸€æ®µ">â†“</button>` : ''}
                  </div>
                </div>
              `;
              for (let i = 0; i < aligned.length; i++) {
                html += `
                  <div class="align-flex block-flex block-flex-${blockIndex} ${showMode==='ocr'?'block-mode-ocr-only':showMode==='trans'?'block-mode-trans-only':'block-mode-both'}" data-block="${blockIndex}" data-align-index="${i}">
                    <div class="align-block align-block-ocr">
                      <div class="align-title">
                        <span>åŸæ–‡</span>
                        <button class="block-struct-copy-btn" data-block="${blockIndex}" data-type="ocr" data-idx="${i}" title="å¤åˆ¶åŸæ–‡ç»“æ„">å¤åˆ¶</button>
                      </div>
                      <div class="align-content markdown-body">${MarkdownProcessor.renderWithKatexFailback(MarkdownProcessor.safeMarkdown(aligned[i][0], images), isOriginalFirstInChunkCompare ? ocrRenderer : transRenderer)}</div>
                    </div>
                    <div class="splitter" title="æ‹–åŠ¨è°ƒæ•´æ¯”ä¾‹"></div>
                    <div class="align-block align-block-trans">
                      <div class="align-title">
                        <span>è¯‘æ–‡</span>
                        <button class="block-struct-copy-btn" data-block="${blockIndex}" data-type="trans" data-idx="${i}" title="å¤åˆ¶è¯‘æ–‡ç»“æ„">å¤åˆ¶</button>
                      </div>
                      <div class="align-content markdown-body">${MarkdownProcessor.renderWithKatexFailback(MarkdownProcessor.safeMarkdown(aligned[i][1], images), isOriginalFirstInChunkCompare ? transRenderer : ocrRenderer)}</div>
                    </div>
                  </div>
                `;
              }
              // è®°å½•åŸå§‹å†…å®¹ï¼Œä¾›å¤åˆ¶ç”¨
              window[`blockRawContent_${blockIndex}`] = aligned;
              return html;
            }
            // æ¸²æŸ“æ¯ä¸ªåˆ†å—ï¼Œå¢åŠ å”¯ä¸€id
            for (let i = 0; i < data.ocrChunks.length; i++) {
                const ocrChunk = data.ocrChunks[i] || '';
                const translatedChunk = data.translatedChunks[i] || '';
                let blockHtmlToRender;
                let outerBlockTitle;

                if (isOriginalFirstInChunkCompare) {
                    // å½“åŸæ–‡åœ¨å·¦ä¾§æ—¶ï¼Œè°ƒç”¨ renderLevelAlignedFlex(åŸæ–‡, è¯‘æ–‡)
                    // window[`blockRawContent_${i}`] å°†å­˜å‚¨ [åŸæ–‡å­å—, è¯‘æ–‡å­å—]
                    blockHtmlToRender = renderLevelAlignedFlex(ocrChunk, translatedChunk, data.images, i, data.ocrChunks.length);
                    outerBlockTitle = `åŸæ–‡å— ${i+1}`;
                } else {
                    // å½“è¯‘æ–‡åœ¨å·¦ä¾§æ—¶ï¼Œè°ƒç”¨ renderLevelAlignedFlex(è¯‘æ–‡, åŸæ–‡)
                    // window[`blockRawContent_${i}`] å°†å­˜å‚¨ [è¯‘æ–‡å­å—, åŸæ–‡å­å—]
                    blockHtmlToRender = renderLevelAlignedFlex(translatedChunk, ocrChunk, data.images, i, data.ocrChunks.length);
                    outerBlockTitle = `è¯‘æ–‡å— ${i+1}`; // æ ‡é¢˜ä¹Ÿåæ˜ å·¦ä¾§å†…å®¹
                }
                html += `<div class="chunk-pair">`;
                html += `<div id="block-${i}" class="block-outer">`; // id ç”¨äºå¯¼èˆª
                html += `<h4>${outerBlockTitle}</h4>`;
                html += blockHtmlToRender;
                html += `</div></div>`;
            }
            html += '</div>';
            // ç»‘å®šæ¯ä¸ªåˆ†å—çš„åˆ‡æ¢æŒ‰é’®å’Œå¯¼èˆªæŒ‰é’®äº‹ä»¶
            setTimeout(() => {
              // æ‹–åŠ¨åˆ†å‰²æ¡å®ç° - ä½¿ç”¨CSSå˜é‡è€Œä¸æ˜¯ç›´æ¥è®¾ç½®æ ·å¼
              let ratio = window.chunkCompareRatio;
              if (typeof ratio !== 'number' || isNaN(ratio)) ratio = 0.5;
              window.chunkCompareRatio = ratio; // ç¡®ä¿å…¨å±€å˜é‡è¢«è®¾ç½®

              function applyRatioToAll() {
                const currentRatio = window.chunkCompareRatio || 0.5;
                document.querySelectorAll('.align-flex').forEach(flex => {
                  // ä½¿ç”¨CSSå˜é‡è€Œä¸æ˜¯ç›´æ¥è®¾ç½®æ ·å¼
                  flex.style.setProperty('--ocr-ratio', (currentRatio * 100) + '%');
                  flex.style.setProperty('--trans-ratio', ((1 - currentRatio) * 100) + '%');
                });
              }
              applyRatioToAll();

              // ä»¥ä¸‹æ˜¯æ—§çš„æ‹–åŠ¨å®ç°ï¼Œå·²è¢«æ–°çš„å®ç°æ›¿ä»£ï¼Œç§»é™¤ä»¥é¿å…å†²çª
              /*
              let dragging = false;
              let startX = 0;
              let startRatio = ratio;
              document.querySelectorAll('.splitter').forEach(splitter => {
                splitter.onmousedown = function(e) {
                  dragging = true;
                  startX = e.clientX;
                  startRatio = ratio;
                  splitter.classList.add('active');
                  // ä½¿ç”¨CSSç±»è€Œä¸æ˜¯ç›´æ¥è®¾ç½®æ ·å¼
                  document.body.classList.add('dragging-cursor');
                  e.preventDefault();
                };
              });

              document.addEventListener('mousemove', function(e) {
                if (!dragging) return;
                const flex = document.querySelector('.align-flex');
                if (!flex) return;
                const rect = flex.getBoundingClientRect();
                let dx = e.clientX - startX;
                let newRatio = startRatio + dx / rect.width;
                newRatio = Math.max(0.3, Math.min(0.7, newRatio));
                window.chunkCompareRatio = newRatio;
                ratio = newRatio;
                applyRatioToAll();
              });

              document.addEventListener('mouseup', function() {
                if (dragging) {
                  dragging = false;
                  // ä½¿ç”¨CSSç±»è€Œä¸æ˜¯ç›´æ¥è®¾ç½®æ ·å¼
                  document.body.classList.remove('dragging-cursor');
                  document.querySelectorAll('.splitter').forEach(s => s.classList.remove('active'));
                }
              });
              */

              // é‡æ–°ç»‘å®šåˆ†å—å¯¹æ¯”å·¥å…·æ æŒ‰é’®äº‹ä»¶ - ä½¿ç”¨CSSç±»ç®¡ç†æ˜¾ç¤ºæ¨¡å¼
              document.querySelectorAll('.block-mode-btn').forEach(btn => {
                btn.onclick = function() {
                  const blockIndex = this.dataset.block;
                  const mode = this.dataset.mode;
                  window[`showMode_block_${blockIndex}`] = mode;

                  // æ›´æ–°æŒ‰é’®æ¿€æ´»çŠ¶æ€
                  document.querySelectorAll(`.block-mode-btn[data-block="${blockIndex}"]`).forEach(b => {
                    b.classList.remove('active');
                  });
                  this.classList.add('active');

                  // ä½¿ç”¨CSSç±»ç®¡ç†æ˜¾ç¤ºæ¨¡å¼ï¼Œè€Œä¸æ˜¯ç›´æ¥æ“ä½œæ ·å¼
                  document.querySelectorAll(`.block-flex-${blockIndex}`).forEach(flexPair => {
                    // ç§»é™¤æ‰€æœ‰æ¨¡å¼ç±»
                    flexPair.classList.remove('block-mode-ocr-only', 'block-mode-trans-only', 'block-mode-both');

                    // æ·»åŠ å¯¹åº”çš„æ¨¡å¼ç±»
                    if (mode === 'ocr') {
                      flexPair.classList.add('block-mode-ocr-only');
                    } else if (mode === 'trans') {
                      flexPair.classList.add('block-mode-trans-only');
                    } else { // mode === 'both'
                      flexPair.classList.add('block-mode-both');
                      // å½“åˆ‡æ¢å› both æ¨¡å¼æ—¶ï¼Œé‡æ–°åº”ç”¨æ‹–åŠ¨æ¡çš„æ¯”ä¾‹
                      applyRatioToAllFlexPairsInBlock(blockIndex);
                    }
                  });
                };
              });

              // è¾…åŠ©å‡½æ•°ï¼šå°†å½“å‰æ‹–åŠ¨æ¯”ä¾‹åº”ç”¨åˆ°æŒ‡å®šblockIndexçš„æ‰€æœ‰flexPair
              function applyRatioToAllFlexPairsInBlock(blockIndexToUpdate) {
                const currentRatio = window.chunkCompareRatio || 0.5;
                document.querySelectorAll(`.block-flex-${blockIndexToUpdate}`).forEach(flex => {
                  // ä½¿ç”¨CSSå˜é‡
                  flex.style.setProperty('--ocr-ratio', (currentRatio * 100) + '%');
                  flex.style.setProperty('--trans-ratio', ((1 - currentRatio) * 100) + '%');
                });
              }

              // åˆå§‹åŒ–æ‹–åŠ¨æ¯”ä¾‹åº”ç”¨åˆ°æ‰€æœ‰åˆ†å—çš„æ‰€æœ‰å¯¹æ¯”å¯¹
              // ç¡®ä¿åœ¨æŒ‰é’®äº‹ä»¶ç»‘å®šä¹‹åï¼Œä½†åœ¨ç¬¬ä¸€æ¬¡æ¸²æŸ“æ—¶å°±èƒ½æ­£ç¡®è®¾ç½®
              if (document.querySelector('.align-flex')) { // ç¡®ä¿æœ‰å¯æ“ä½œçš„å…ƒç´ 
                const allBlockIndexes = new Set();
                document.querySelectorAll('[data-block]').forEach(el => allBlockIndexes.add(el.dataset.block));
                allBlockIndexes.forEach(idx => {
                    if(window[`showMode_block_${idx}`] === undefined || window[`showMode_block_${idx}`] === 'both') {
                        applyRatioToAllFlexPairsInBlock(idx);
                    }
                });
              }

              // æ‹–åŠ¨åˆ†å‰²æ¡å®ç°
              let draggingSplitterInfo = null; // {splitter, flexContainer, startX, initialOcrBasisPx}

              document.querySelectorAll('.splitter').forEach(splitter => {
                splitter.onmousedown = function(e) {
                  const flexContainer = e.target.closest('.align-flex');
                  if (!flexContainer) return;
                  const ocrBlock = flexContainer.querySelector('.align-block-ocr');
                  if (!ocrBlock || getComputedStyle(ocrBlock).display === 'none') return; // åªåœ¨å¯¹æ¯”æ¨¡å¼ä¸‹æ‹–åŠ¨

                  draggingSplitterInfo = {
                    splitter: e.target,
                    flexContainer: flexContainer,
                    startX: e.clientX,
                    initialOcrBasisPx: ocrBlock.offsetWidth
                  };

                  e.target.classList.add('active');
                  // ä½¿ç”¨CSSç±»è€Œä¸æ˜¯ç›´æ¥è®¾ç½®æ ·å¼
                  document.body.classList.add('dragging-cursor');
                  e.preventDefault();
                };
              });

              document.addEventListener('mousemove', function(e) {
                if (!draggingSplitterInfo) return;

                const { splitter, flexContainer, startX, initialOcrBasisPx } = draggingSplitterInfo;
                const ocrBlock = flexContainer.querySelector('.align-block-ocr');
                const transBlock = flexContainer.querySelector('.align-block-trans');
                if (!ocrBlock || !transBlock) return;

                const dx = e.clientX - startX;
                const containerWidth = flexContainer.offsetWidth;
                if (containerWidth === 0) return;

                let newOcrWidthPx = initialOcrBasisPx + dx;
                // é™åˆ¶æœ€å°/æœ€å¤§å®½åº¦ï¼Œä¾‹å¦‚æ€»å®½åº¦çš„20%åˆ°80%
                const minWidthPx = containerWidth * 0.2;
                const maxWidthPx = containerWidth * 0.8;
                newOcrWidthPx = Math.max(minWidthPx, Math.min(newOcrWidthPx, maxWidthPx));

                const newOcrRatio = newOcrWidthPx / containerWidth;

                // æ›´æ–°å½“å‰æ‹–åŠ¨çš„å—çš„æ¯”ä¾‹
                flexContainer.style.setProperty('--ocr-ratio', (newOcrRatio * 100) + '%');
                flexContainer.style.setProperty('--trans-ratio', ((1 - newOcrRatio) * 100) + '%');

                // æ›´æ–°å…¨å±€æ¯”ä¾‹ï¼Œä»¥ä¾¿æ–°åŠ è½½çš„å—æˆ–åˆ‡æ¢å›å¯¹æ¯”æ¨¡å¼æ—¶ä½¿ç”¨
                window.chunkCompareRatio = newOcrRatio;

                // è°ƒç”¨applyRatioToAll()ä½¿æ‰€æœ‰å…¶ä»–å—çš„æ¯”ä¾‹è”åŠ¨
                // ä½†æ’é™¤å½“å‰æ­£åœ¨æ‹–åŠ¨çš„å—ï¼Œé¿å…è§†è§‰æŠ–åŠ¨
                document.querySelectorAll('.align-flex').forEach(flex => {
                  if (flex !== flexContainer) {
                    flex.style.setProperty('--ocr-ratio', (newOcrRatio * 100) + '%');
                    flex.style.setProperty('--trans-ratio', ((1 - newOcrRatio) * 100) + '%');
                  }
                });
              });

              document.addEventListener('mouseup', function() {
                if (draggingSplitterInfo) {
                  draggingSplitterInfo.splitter.classList.remove('active');
                  draggingSplitterInfo = null;
                  // ä½¿ç”¨CSSç±»è€Œä¸æ˜¯ç›´æ¥è®¾ç½®æ ·å¼
                  document.body.classList.remove('dragging-cursor');

                  // ä¸å†éœ€è¦è°ƒç”¨applyRatioToAllï¼Œå› ä¸ºåœ¨mousemoveä¸­å·²ç»åº”ç”¨äº†æ¯”ä¾‹
                  // if (typeof window.chunkCompareRatio === 'number') {
                  //   applyRatioToAll();
                  // }

                  // æŒä¹…åŒ–å½“å‰çš„æ¯”ä¾‹è®¾ç½®åˆ°localStorage
                  if (docIdForLocalStorage && typeof window.chunkCompareRatio === 'number') {
                    localStorage.setItem(`chunkCompareRatio_${docIdForLocalStorage}`, window.chunkCompareRatio.toString());
                  }
                }
              });

              document.querySelectorAll('.block-copy-btn').forEach(btn => {
                btn.onclick = function() {
                  const blockIndex = this.dataset.block;
                  const rawBlockContent = window[`blockRawContent_${blockIndex}`];
                  const currentMode = window[`showMode_block_${blockIndex}`] || 'both'; // è·å–å½“å‰æ¨¡å¼

                  if (rawBlockContent && Array.isArray(rawBlockContent)) {
                    let textToCopy = "";
                    let alertMessage = "";

                    if (currentMode === 'ocr') {
                      rawBlockContent.forEach(pair => {
                        // å¦‚æœåŸæ–‡åœ¨å·¦ï¼Œpair[0]æ˜¯åŸæ–‡ï¼›å¦‚æœè¯‘æ–‡åœ¨å·¦ï¼Œpair[0]æ˜¯è¯‘æ–‡
                        const ocrText = isOriginalFirstInChunkCompare ? (pair && pair[0]) : (pair && pair[1]);
                        if (ocrText) textToCopy += ocrText + "\n\n";
                      });
                      textToCopy = textToCopy.trim();
                      alertMessage = `ç¬¬ ${parseInt(blockIndex) + 1} å—çš„ åŸæ–‡ å·²å¤åˆ¶!`;
                    } else if (currentMode === 'trans') {
                      rawBlockContent.forEach(pair => {
                        // å¦‚æœåŸæ–‡åœ¨å·¦ï¼Œpair[1]æ˜¯è¯‘æ–‡ï¼›å¦‚æœè¯‘æ–‡åœ¨å·¦ï¼Œpair[1]æ˜¯åŸæ–‡
                        const transText = isOriginalFirstInChunkCompare ? (pair && pair[1]) : (pair && pair[0]);
                        if (transText) textToCopy += transText + "\n\n";
                      });
                      textToCopy = textToCopy.trim();
                      alertMessage = `ç¬¬ ${parseInt(blockIndex) + 1} å—çš„ è¯‘æ–‡ å·²å¤åˆ¶!`;
                    } else { // mode === 'both'
                      rawBlockContent.forEach(pair => {
                        const ocrText = isOriginalFirstInChunkCompare ? (pair && pair[0]) : (pair && pair[1]);
                        const transText = isOriginalFirstInChunkCompare ? (pair && pair[1]) : (pair && pair[0]);
                        if (ocrText) textToCopy += "åŸæ–‡:\n" + ocrText + "\n\n";
                        if (transText) textToCopy += "è¯‘æ–‡:\n" + transText + "\n\n";
                      });
                      textToCopy = textToCopy.trim();
                      alertMessage = `ç¬¬ ${parseInt(blockIndex) + 1} å—çš„ åŸæ–‡å’Œè¯‘æ–‡ å·²å¤åˆ¶!`;
                    }

                    if (textToCopy) {
                      navigator.clipboard.writeText(textToCopy)
                        .then(() => alert(alertMessage))
                        .catch(err => {
                          console.error('å¤åˆ¶å¤±è´¥:', err);
                          alert('å¤åˆ¶å¤±è´¥ï¼Œè¯·æŸ¥çœ‹æ§åˆ¶å°ã€‚');
                        });
                    } else {
                      alert('æ²¡æœ‰å†…å®¹å¯å¤åˆ¶ã€‚');
                    }
                  }
                };
              });

              document.querySelectorAll('.block-struct-copy-btn').forEach(btn => {
                btn.onclick = function() {
                  const blockIndex = this.dataset.block;
                  const type = this.dataset.type; // 'ocr' or 'trans'
                  const structIdx = parseInt(this.dataset.idx);
                  const rawBlockContent = window[`blockRawContent_${blockIndex}`];
                  if (rawBlockContent && rawBlockContent[structIdx]) {
                    const textToCopy = (type === 'ocr') ? rawBlockContent[structIdx][0] : rawBlockContent[structIdx][1];
                    navigator.clipboard.writeText(textToCopy)
                      .then(() => alert(`ç¬¬ ${parseInt(blockIndex) + 1} å—çš„ ${type === 'ocr' ? 'åŸæ–‡' : 'è¯‘æ–‡'} (ç»“æ„ ${structIdx + 1}) å·²å¤åˆ¶!`))
                      .catch(err => console.error('å¤åˆ¶å¤±è´¥:', err));
                  }
                };
              });

              document.querySelectorAll('.block-nav-btn').forEach(btn => {
                btn.onclick = function() {
                  const blockIndex = parseInt(this.dataset.block);
                  const direction = this.dataset.dir;
                  let targetIndex = direction === 'prev' ? blockIndex - 1 : blockIndex + 1;
                  const targetElement = document.getElementById(`block-${targetIndex}`);
                  if (targetElement) {
                    targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    // å¯é€‰ï¼šæ·»åŠ é«˜äº®æ•ˆæœ
                    targetElement.classList.add('block-highlight');
                    setTimeout(() => targetElement.classList.remove('block-highlight'), 1500);
                  }
                };
              });

            }, 0);
        } else {
            html = '<h3>åˆ†å—å¯¹æ¯”</h3><p>æ­¤è®°å½•æ²¡æœ‰æœ‰æ•ˆçš„åˆ†å—å¯¹æ¯”æ•°æ®ã€‚</p>';
            if (!data.ocrChunks || !data.translatedChunks) {
                 html += '<p>åŸå› ï¼šç¼ºå°‘åˆ†å—æ•°æ® (ocrChunks or translatedChunks missing)ã€‚</p>';
            } else if (data.ocrChunks.length !== data.translatedChunks.length) {
                 html += `<p>åŸå› ï¼šåŸæ–‡å—æ•°é‡ (${data.ocrChunks.length}) ä¸è¯‘æ–‡å—æ•°é‡ (${data.translatedChunks.length}) ä¸åŒ¹é…ã€‚</p>`;
            } else {
                 html += '<p>åŸå› ï¼šåˆ†å—æ•°æ®ä¸ºç©ºã€‚</p>';
            }
        }
      }
      document.getElementById('tabContent').innerHTML = html;

      // NEW: Adjust long headings. This should be called AFTER innerHTML is set
      // and BEFORE refreshTocList is called.
      const tabContentElement = document.getElementById('tabContent');
      if (tabContentElement) {
          adjustLongHeadingsToParagraphs(tabContentElement);
      }

      if (typeof window.refreshTocList === 'function') {
        window.refreshTocList(); // æ›´æ–°TOC
      }

      // Update reading progress when tab changes and content is rendered - CALLING DOCK_LOGIC
      if (window.DockLogic && typeof window.DockLogic.forceUpdateReadingProgress === 'function') {
        window.DockLogic.forceUpdateReadingProgress();
      }

      // å¦‚æœæ˜¯åˆ†å—å¯¹æ¯”è§†å›¾ï¼Œå¹¶ä¸”æŒ‰é’®å­˜åœ¨ï¼Œåˆ™ç»‘å®šäº‹ä»¶
      if (tab === 'chunk-compare') {
        const swapBtn = document.getElementById('swap-chunks-btn');
        if (swapBtn) {
            swapBtn.onclick = function() {
                isOriginalFirstInChunkCompare = !isOriginalFirstInChunkCompare;
                showTab('chunk-compare'); // é‡æ–°æ¸²æŸ“åˆ†å—å¯¹æ¯”è§†å›¾
            };
        }
      }

      // After tab content is updated, refresh chatbot UI if it's open
      if (window.isChatbotOpen && typeof window.ChatbotUI !== 'undefined' && typeof window.ChatbotUI.updateChatbotUI === 'function') {
        window.ChatbotUI.updateChatbotUI();
      }

      // åº”ç”¨é«˜äº®å’Œæ‰¹æ³¨
      if ((tab === 'ocr' || tab === 'translation') && contentContainerId) {
        activeContentElement = document.getElementById(contentContainerId);
        if (activeContentElement) {
            const directChildNodes = Array.from(activeContentElement.children);
            const blockElements = directChildNodes.filter(node =>
                node.nodeType === Node.ELEMENT_NODE && true
            );
            blockElements.forEach((element, index) => {
                element.dataset.blockIndex = String(index);
                // MODIFIED to use SubBlockSegmenter
                if (typeof window.SubBlockSegmenter !== 'undefined' && typeof window.SubBlockSegmenter.segment === 'function') {
                    window.SubBlockSegmenter.segment(element, index);
                } else {
                    console.error("SubBlockSegmenter.segment is not available.");
                }
            });

            if (data && data.annotations) {
                if (typeof window.applyBlockAnnotations === 'function') {
                    console.log(`[showTab] ä¸º ${window.globalCurrentContentIdentifier} è°ƒç”¨å—çº§æ‰¹æ³¨åº”ç”¨å‡½æ•° (æ“ä½œå¯¹è±¡å°†æ˜¯å­å—)`);
                    window.applyBlockAnnotations(activeContentElement, data.annotations, window.globalCurrentContentIdentifier);
                } else {
                    console.warn("[showTab] å—çº§/å­å—æ‰¹æ³¨åº”ç”¨å‡½æ•° (applyBlockAnnotations) æœªå®šä¹‰ã€‚è¯·æ£€æŸ¥ js/annotation_highlighter.js");
                }
            }
        }
        if (typeof window.addAnnotationListenersToContainer === 'function') {
            // ä¸º OCR å’Œ Translation è§†å›¾ä¼ é€’å½“å‰çš„å…¨å±€å†…å®¹æ ‡è¯†ç¬¦
            window.addAnnotationListenersToContainer(contentContainerId, window.globalCurrentContentIdentifier);
        } else {
            console.error("addAnnotationListenersToContainer æœªå®šä¹‰ã€‚è¯·æ£€æŸ¥ js/annotation_logic.js");
        }
      } else if (tab === 'chunk-compare') {
         // å¯¹äºåˆ†å—å¯¹æ¯”è§†å›¾ï¼Œä¸ºæ¯ä¸ªåŸæ–‡å’Œè¯‘æ–‡å—å•ç‹¬å¤„ç†
         setTimeout(() => { //ç¡®ä¿DOMæ›´æ–°å®Œæ¯•
            const ocrContentAreas = document.querySelectorAll('.chunk-compare-container .align-block-ocr .align-content.markdown-body');
            const transContentAreas = document.querySelectorAll('.chunk-compare-container .align-block-trans .align-content.markdown-body');

            function processContentArea(area, isOcrArea) {
                if (!area.id) {
                    area.id = 'chunk-content-' + _page_generateUUID();
                }
                const effectiveContentIdentifier = isOriginalFirstInChunkCompare ? (isOcrArea ? 'ocr' : 'translation') : (isOcrArea ? 'translation' : 'ocr');

                // 1. åˆ†å‰²å­å—
                const directChildNodes = Array.from(area.children);
                const blockElements = directChildNodes.filter(node => node.nodeType === Node.ELEMENT_NODE);
                blockElements.forEach((element, index) => {
                    element.dataset.blockIndex = String(index); // ä¸ºæ¯ä¸ªå—å†…å…ƒç´ è®¾ç½®ç‹¬ç«‹çš„ blockIndex
                    // MODIFIED to use SubBlockSegmenter
                    if (typeof window.SubBlockSegmenter !== 'undefined' && typeof window.SubBlockSegmenter.segment === 'function') {
                        window.SubBlockSegmenter.segment(element, index);
                    } else {
                        console.error("SubBlockSegmenter.segment is not available for chunk processing.");
                    }
                });

                // 2. åº”ç”¨æ‰¹æ³¨
                if (data && data.annotations && typeof window.applyBlockAnnotations === 'function') {
                    // console.log(`[showTab ChunkCompare] ä¸º ${area.id} (ç±»å‹: ${effectiveContentIdentifier}) åº”ç”¨æ‰¹æ³¨`);
                    // MODIFIED: Pass empty array for annotations in chunk-compare mode
                    const annotationsToApply = (currentVisibleTabId === 'chunk-compare') ? [] : data.annotations;
                    window.applyBlockAnnotations(area, annotationsToApply, effectiveContentIdentifier);
                }

                // 3. æ·»åŠ ç›‘å¬å™¨
                if (typeof window.addAnnotationListenersToContainer === 'function') {
                    // console.log(`[showTab ChunkCompare] ä¸º ${area.id} (ç±»å‹: ${effectiveContentIdentifier}) æ·»åŠ ç›‘å¬å™¨`);
                    window.addAnnotationListenersToContainer(area.id, effectiveContentIdentifier);
                }
            }

            ocrContentAreas.forEach(area => processContentArea(area, true));
            transContentAreas.forEach(area => processContentArea(area, false));

         }, 0);
      }

      // Attempt to restore scroll position for the current tab
      if (docIdForLocalStorage && currentVisibleTabId) {
        const scrollKey = `scrollPos_${docIdForLocalStorage}_${currentVisibleTabId}`;
        const savedScrollTop = localStorage.getItem(scrollKey);
        // console.log(`[showTab] Attempting to restore scroll for ${scrollKey} on documentElement. Saved value: ${savedScrollTop}`);
        if (savedScrollTop !== null && !isNaN(parseInt(savedScrollTop, 10))) {
          const scrollableElement = document.documentElement; // Changed from .container
          if (scrollableElement) {
            requestAnimationFrame(() => {
              if(currentVisibleTabId === tab) { // Ensure tab hasn't changed during async operation
                scrollableElement.scrollTop = parseInt(savedScrollTop, 10);
                // console.log(`[showTab] Restored scroll for ${scrollKey} (tab: ${tab}) on documentElement to ${scrollableElement.scrollTop}`);
              }
            });
          }
        }
      }
      // Call updateReadingProgress after potential scroll restoration and content rendering - CALLING DOCK_LOGIC
      if (window.DockLogic && typeof window.DockLogic.forceUpdateReadingProgress === 'function') {
        window.DockLogic.forceUpdateReadingProgress();
      }
      // updateAllDockStats(); // Update all dock stats after tab content is fully processed - CALLING DOCK_LOGIC
      if (window.DockLogic && typeof window.DockLogic.updateStats === 'function') {
        window.DockLogic.updateStats(window.data, currentVisibleTabId);
      }
    }
    // ç»‘å®štabæŒ‰é’®ç‚¹å‡»äº‹ä»¶
    document.getElementById('tab-ocr').onclick = function() { showTab('ocr'); };
    document.getElementById('tab-translation').onclick = function() { showTab('translation'); };
    // document.getElementById('tab-compare').onclick = function() { showTab('compare'); }; // ç‚¹å‡»äº‹ä»¶æ³¨é‡Šæ‰
    document.getElementById('tab-chunk-compare').onclick = function() { showTab('chunk-compare'); };

    // é¡µé¢åŠ è½½åæ¸²æŸ“è¯¦æƒ…
    renderDetail();

    /**
     * å°†æ‰¹æ³¨åº”ç”¨åˆ°æŒ‡å®šçš„å†…å®¹å®¹å™¨ä¸Šã€‚
     * @param {HTMLElement} containerElement - å†…å®¹çš„DOMå®¹å™¨ (ä¾‹å¦‚åŒ…å«OCRæˆ–ç¿»è¯‘æ–‡æœ¬çš„div)ã€‚
     * @param {Array<Object>} annotations - å½“å‰æ–‡æ¡£çš„æ‰¹æ³¨å¯¹è±¡æ•°ç»„ã€‚
     * @param {string} contentIdentifier - å†…å®¹ç±»å‹æ ‡è¯†ç¬¦ (ä¾‹å¦‚ 'ocr', 'translation')ã€‚
     */
    // MOVED to js/annotation_logic.js: function applyAnnotationsToContent(...) {...}

    // ==========================
    // è‡ªå®šä¹‰ä¸Šä¸‹æ–‡èœå•é€»è¾‘ -- MOVED to js/annotation_logic.js
    // ==========================
    // const contextMenu = document.getElementById('custom-context-menu'); // Will be handled by annotation_logic.js

    // MOVED to js/annotation_logic.js: function fuzzyMatch(...) {...}
    // MOVED to js/annotation_logic.js: function checkIfTextIsHighlighted(...) {...}
    // MOVED to js/annotation_logic.js: function checkIfTextHasNote(...) {...}
    // MOVED to js/annotation_logic.js: function updateContextMenuOptions(...) {...}
    // MOVED to js/annotation_logic.js: function showContextMenu(...) {...}
    // MOVED to js/annotation_logic.js: function hideContextMenu(...) {...}
    // MOVED to js/annotation_logic.js: function addContextMenuListener(...) {...} // Renamed to addAnnotationListenersToContainer
    // MOVED to js/annotation_logic.js: contextMenu.addEventListener('click', async (event) => {...});
    // MOVED to js/annotation_logic.js: document.addEventListener('click', (event) => {...});
    // MOVED to js/annotation_logic.js: function _page_generateUUID() {...}

    /**
     * @namespace TocFeature
     * @description ç®¡ç†é¡µé¢å³ä¾§æµ®åŠ¨çš„ç›®å½• (Table of Contents) åŠŸèƒ½ã€‚
     * åŒ…æ‹¬TOCæŒ‰é’®çš„ç‚¹å‡»äº‹ä»¶ã€TOCæ‚¬æµ®çª—çš„æ˜¾ç¤º/éšè—ã€
     * ä»¥åŠåŠ¨æ€ç”ŸæˆTOCåˆ—è¡¨é¡¹ã€‚
     */
    // MOVED to js/toc_logic.js: (function TocFeature(){...})();

    /**
     * ç›‘å¬ localStorage çš„ `storage` äº‹ä»¶ã€‚
     * å¦‚æœ `paperBurnerSettings` å‘ç”Ÿå˜åŒ–ï¼ˆé€šå¸¸åœ¨ä¸»é¡µé¢ä¿®æ”¹è®¾ç½®å¯¼è‡´ï¼‰ï¼Œ
     * å°è¯•æ›´æ–°èŠå¤©æœºå™¨äºº (Chatbot) çš„é…ç½®æˆ–UIï¼ˆå¦‚æœç›¸å…³æ¨¡å—å·²åŠ è½½å¹¶å¯ç”¨ï¼‰ã€‚
     * @param {StorageEvent} e - storage äº‹ä»¶å¯¹è±¡ã€‚
     */
    window.addEventListener('storage', function(e) {
      if (e.key === 'paperBurnerSettings') {
        // é‡æ–°åŠ è½½è®¾ç½®å¹¶åˆ·æ–° chatbot é…ç½®
        if (window.ChatbotCore && typeof window.ChatbotCore.getChatbotConfig === 'function') {
          // ä½ å¯ä»¥å¼ºåˆ¶åˆ·æ–° Chatbot UI æˆ–é‡è½½é…ç½®
          window.ChatbotUI && window.ChatbotUI.updateChatbotUI && window.ChatbotUI.updateChatbotUI();
        }
      }
    });

    /**
     * å°† exact æ–‡æœ¬è½¬ä¸ºæ¨¡ç³Šæ­£åˆ™ï¼Œå…è®¸ç©ºæ ¼ã€æ¢è¡Œæ¨¡ç³ŠåŒ¹é…ï¼Œå¤§å°å†™ä¸æ•æ„Ÿ
     * @param {string} exact
     * @returns {RegExp}
     */
    function escapeRegExp(string) {
      // æ›´å®‰å…¨åœ°è½¬ä¹‰æ‰€æœ‰æ­£åˆ™ç‰¹æ®Šå­—ç¬¦
      return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }
    function fuzzyRegFromExact(exact) {
      // å…ˆè½¬ä¹‰æ‰€æœ‰æ­£åˆ™ç‰¹æ®Šå­—ç¬¦
      let pattern = escapeRegExp(exact);
      // å°†æ‰€æœ‰ç©ºç™½æ›¿æ¢ä¸º \s+ï¼Œå…è®¸è·¨è¡Œã€å¤šä¸ªç©ºæ ¼
      pattern = pattern.replace(/\s+/g, '\\s+');
      // å¯é€‰ï¼šå¿½ç•¥å‰åç©ºç™½
      pattern = '\\s*' + pattern + '\\s*';
      return new RegExp(pattern, 'gi');
    }

    // function highlightTextWithAnnotations(text, annotations, contentIdentifier) { // Obsolete due to block based.
    //   console.warn('[highlightTextWithAnnotations] This function is part of the old text-based highlighting system and should ideally be phased out.');
    //   if (!annotations || !Array.isArray(annotations) || !text) return text;
    //   // åªå¤„ç†å½“å‰å†…å®¹ç±»å‹çš„é«˜äº®
    //   const relevant = annotations.filter(
    //     ann =>
    //       ann.targetType === contentIdentifier &&
    //       ann.target &&
    //       Array.isArray(ann.target.selector) &&
    //       ann.target.selector[0] &&
    //       ann.target.selector[0].exact
    //   );
    //   if (relevant.length === 0) return text;

    //   // æŒ‰ç…§ exact é•¿åº¦é™åºæ’åºï¼Œé¿å…åµŒå¥—è¦†ç›–
    //   relevant.sort((a, b) => (b.target.selector[0].exact.length - a.target.selector[0].exact.length));

    //   let result = text;
    //   relevant.forEach(ann => {
    //     const color = ann.highlightColor || 'yellow';
    //     const note = ann.body && ann.body.length > 0 && ann.body[0].value ? ann.body[0].value : '';
    //     const exact = ann.target.selector[0].exact;
    //     const reg = fuzzyRegFromExact(exact);
    //     result = result.replace(
    //       reg,
    //       `<mark class="annotation-highlight" style="background:${color}" title="${note.replace(/"/g, '&quot;')}">$&</mark>`
    //     );
    //   });
    //   return result;
    // }

    /**
     * ä»æ•°æ®åº“ä¸­ç§»é™¤æŒ‡å®šæ–‡æœ¬çš„é«˜äº®æ‰¹æ³¨
     * @param {string} selectedText - è¦å–æ¶ˆé«˜äº®çš„æ–‡æœ¬
     * @param {string} docId - æ–‡æ¡£ID
     */
    // MOVED to js/annotation_logic.js: async function removeHighlightFromText(selectedText, docId) {...}

    /**
     * ä¸ºç°æœ‰çš„é«˜äº®æ–‡æœ¬æ·»åŠ æ‰¹æ³¨
     * @param {string} selectedText - é€‰ä¸­çš„æ–‡æœ¬
     * @param {string} noteText - æ‰¹æ³¨å†…å®¹
     * @param {string} docId - æ–‡æ¡£ID
     */
    // MOVED to js/annotation_logic.js: async function addNoteToExistingHighlight(selectedText, noteText, docId) {...}

    // Dock Settings Modal Logic
    // MOVED to js/dock_settings_modal.js

    // Annotations/Highlights Summary Modal Logic
    // MOVED to js/annotations_summary_modal.js
  </script>

</body>
</html>